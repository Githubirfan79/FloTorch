[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "config.config",
        "description": "config.config",
        "isExtraImport": true,
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "isExtraImport": true,
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "boto3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "boto3",
        "description": "boto3",
        "detail": "boto3",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "botocore.client",
        "description": "botocore.client",
        "isExtraImport": true,
        "detail": "botocore.client",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BackgroundTasks",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "GuardRailsUtils",
        "importPath": "util.guard_rails_utils",
        "description": "util.guard_rails_utils",
        "isExtraImport": true,
        "detail": "util.guard_rails_utils",
        "documentation": {}
    },
    {
        "label": "KnowledgeBaseUtils",
        "importPath": "util.bedrock_utils",
        "description": "util.bedrock_utils",
        "isExtraImport": true,
        "detail": "util.bedrock_utils",
        "documentation": {}
    },
    {
        "label": "KnowledgeBaseUtils",
        "importPath": "util.bedrock_utils",
        "description": "util.bedrock_utils",
        "isExtraImport": true,
        "detail": "util.bedrock_utils",
        "documentation": {}
    },
    {
        "label": "StatusCodes",
        "importPath": "constants",
        "description": "constants",
        "isExtraImport": true,
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "ErrorTypes",
        "importPath": "constants",
        "description": "constants",
        "isExtraImport": true,
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "StatusCodes",
        "importPath": "constants",
        "description": "constants",
        "isExtraImport": true,
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "ErrorTypes",
        "importPath": "constants",
        "description": "constants",
        "isExtraImport": true,
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "StatusCodes",
        "importPath": "constants",
        "description": "constants",
        "isExtraImport": true,
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "OpenSearchUtils",
        "importPath": "util.open_search_config_utils",
        "description": "util.open_search_config_utils",
        "isExtraImport": true,
        "detail": "util.open_search_config_utils",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "importPath": "util.s3util",
        "description": "util.s3util",
        "isExtraImport": true,
        "detail": "util.s3util",
        "documentation": {}
    },
    {
        "label": "DateTimeUtils",
        "importPath": "util.date_time_utils",
        "description": "util.date_time_utils",
        "isExtraImport": true,
        "detail": "util.date_time_utils",
        "documentation": {}
    },
    {
        "label": "estimate_opensearch_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_sagemaker_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_embedding_model_bedrock_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_retrieval_model_bedrock_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_embedding_model_bedrock_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_retrieval_model_bedrock_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_opensearch_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_sagemaker_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_fargate_price",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_effective_kb_tokens",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_times",
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "isExtraImport": true,
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "read_gt_data",
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "isExtraImport": true,
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "count_characters_in_file",
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "isExtraImport": true,
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "Execution",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseChunker",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseHierarchicalChunker",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEvaluator",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "EvaluationMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "ExperimentQuestionMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "EvaluationMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "ExperimentQuestionMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "EvaluationMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEvaluator",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseInferencer",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseInferencer",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseInferencer",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseChunker",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseHierarchicalChunker",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "VectorDatabase",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "VectorDatabase",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "ExperimentQuestionMetrics",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BotoRetryHandler",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "RetryParams",
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "isExtraImport": true,
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "ValidationStatus",
        "importPath": "constants.validation_status",
        "description": "constants.validation_status",
        "isExtraImport": true,
        "detail": "constants.validation_status",
        "documentation": {}
    },
    {
        "label": "ValidationStatus",
        "importPath": "constants.validation_status",
        "description": "constants.validation_status",
        "isExtraImport": true,
        "detail": "constants.validation_status",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "create_error_response",
        "importPath": "util.error_handling",
        "description": "util.error_handling",
        "isExtraImport": true,
        "detail": "util.error_handling",
        "documentation": {}
    },
    {
        "label": "create_error_response",
        "importPath": "util.error_handling",
        "description": "util.error_handling",
        "isExtraImport": true,
        "detail": "util.error_handling",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "RootModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "http.client",
        "description": "http.client",
        "isExtraImport": true,
        "detail": "http.client",
        "documentation": {}
    },
    {
        "label": "InferencerProviderFactory",
        "importPath": "flotorch_core.inferencer.inferencer_provider_factory",
        "description": "flotorch_core.inferencer.inferencer_provider_factory",
        "isExtraImport": true,
        "detail": "flotorch_core.inferencer.inferencer_provider_factory",
        "documentation": {}
    },
    {
        "label": "VectorStorageFactory",
        "importPath": "flotorch_core.storage.db.vector.vector_storage_factory",
        "description": "flotorch_core.storage.db.vector.vector_storage_factory",
        "isExtraImport": true,
        "detail": "flotorch_core.storage.db.vector.vector_storage_factory",
        "documentation": {}
    },
    {
        "label": "embedding_registry",
        "importPath": "flotorch_core.embedding.embedding_registry",
        "description": "flotorch_core.embedding.embedding_registry",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.embedding_registry",
        "documentation": {}
    },
    {
        "label": "DynamoDB",
        "importPath": "flotorch_core.storage.db.dynamodb",
        "description": "flotorch_core.storage.db.dynamodb",
        "isExtraImport": true,
        "detail": "flotorch_core.storage.db.dynamodb",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "flotorch_core.config.config",
        "description": "flotorch_core.config.config",
        "isExtraImport": true,
        "detail": "flotorch_core.config.config",
        "documentation": {}
    },
    {
        "label": "EnvConfigProvider",
        "importPath": "flotorch_core.config.env_config_provider",
        "description": "flotorch_core.config.env_config_provider",
        "isExtraImport": true,
        "detail": "flotorch_core.config.env_config_provider",
        "documentation": {}
    },
    {
        "label": "Chunk",
        "importPath": "flotorch_core.chunking.chunking",
        "description": "flotorch_core.chunking.chunking",
        "isExtraImport": true,
        "detail": "flotorch_core.chunking.chunking",
        "documentation": {}
    },
    {
        "label": "TitanV2Embedding",
        "importPath": "flotorch_core.embedding.titanv2_embedding",
        "description": "flotorch_core.embedding.titanv2_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.titanv2_embedding",
        "documentation": {}
    },
    {
        "label": "TitanV1Embedding",
        "importPath": "flotorch_core.embedding.titanv1_embedding",
        "description": "flotorch_core.embedding.titanv1_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.titanv1_embedding",
        "documentation": {}
    },
    {
        "label": "CohereEmbedding",
        "importPath": "flotorch_core.embedding.cohere_embedding",
        "description": "flotorch_core.embedding.cohere_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.cohere_embedding",
        "documentation": {}
    },
    {
        "label": "BGELargeEmbedding",
        "importPath": "flotorch_core.embedding.bge_large_embedding",
        "description": "flotorch_core.embedding.bge_large_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.bge_large_embedding",
        "documentation": {}
    },
    {
        "label": "BGEM3Embedding",
        "importPath": "flotorch_core.embedding.bge_large_embedding",
        "description": "flotorch_core.embedding.bge_large_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.bge_large_embedding",
        "documentation": {}
    },
    {
        "label": "GTEQwen2Embedding",
        "importPath": "flotorch_core.embedding.bge_large_embedding",
        "description": "flotorch_core.embedding.bge_large_embedding",
        "isExtraImport": true,
        "detail": "flotorch_core.embedding.bge_large_embedding",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "get_s3_client",
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "isExtraImport": true,
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "isExtraImport": true,
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "extract_text_from_pdf_pymudf",
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "isExtraImport": true,
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "process_pdf_from_folder",
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "isExtraImport": true,
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "isExtraImport": true,
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_execution_model_invocations_db",
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "isExtraImport": true,
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_execution_model_invocations_db",
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "isExtraImport": true,
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "execution",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "experiment",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "health",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "uploads",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "bedrock_config",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "config",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "expert_eval",
        "importPath": "app.routes",
        "description": "app.routes",
        "isExtraImport": true,
        "detail": "app.routes",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "NShotPromptGuide",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "NShotPromptGuide",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "NShotPromptGuide",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "isExtraImport": true,
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "botocore",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "botocore",
        "description": "botocore",
        "detail": "botocore",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "CharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "CharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "BedRockRetryHander",
        "importPath": "util.boto3_utils",
        "description": "util.boto3_utils",
        "isExtraImport": true,
        "detail": "util.boto3_utils",
        "documentation": {}
    },
    {
        "label": "BedRockRetryHander",
        "importPath": "util.boto3_utils",
        "description": "util.boto3_utils",
        "isExtraImport": true,
        "detail": "util.boto3_utils",
        "documentation": {}
    },
    {
        "label": "EmbedderFactory",
        "importPath": "core.embedding",
        "description": "core.embedding",
        "isExtraImport": true,
        "detail": "core.embedding",
        "documentation": {}
    },
    {
        "label": "EmbedderFactory",
        "importPath": "core.embedding",
        "description": "core.embedding",
        "isExtraImport": true,
        "detail": "core.embedding",
        "documentation": {}
    },
    {
        "label": "EmbedderFactory",
        "importPath": "core.embedding",
        "description": "core.embedding",
        "isExtraImport": true,
        "detail": "core.embedding",
        "documentation": {}
    },
    {
        "label": "EmbedderFactory",
        "importPath": "core.embedding",
        "description": "core.embedding",
        "isExtraImport": true,
        "detail": "core.embedding",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "ClientError",
        "importPath": "botocore.exceptions",
        "description": "botocore.exceptions",
        "isExtraImport": true,
        "detail": "botocore.exceptions",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sagemaker.session",
        "description": "sagemaker.session",
        "isExtraImport": true,
        "detail": "sagemaker.session",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sagemaker.session",
        "description": "sagemaker.session",
        "isExtraImport": true,
        "detail": "sagemaker.session",
        "documentation": {}
    },
    {
        "label": "Predictor",
        "importPath": "sagemaker.predictor",
        "description": "sagemaker.predictor",
        "isExtraImport": true,
        "detail": "sagemaker.predictor",
        "documentation": {}
    },
    {
        "label": "Predictor",
        "importPath": "sagemaker.predictor",
        "description": "sagemaker.predictor",
        "isExtraImport": true,
        "detail": "sagemaker.predictor",
        "documentation": {}
    },
    {
        "label": "JSONSerializer",
        "importPath": "sagemaker.serializers",
        "description": "sagemaker.serializers",
        "isExtraImport": true,
        "detail": "sagemaker.serializers",
        "documentation": {}
    },
    {
        "label": "JSONSerializer",
        "importPath": "sagemaker.serializers",
        "description": "sagemaker.serializers",
        "isExtraImport": true,
        "detail": "sagemaker.serializers",
        "documentation": {}
    },
    {
        "label": "JSONDeserializer",
        "importPath": "sagemaker.deserializers",
        "description": "sagemaker.deserializers",
        "isExtraImport": true,
        "detail": "sagemaker.deserializers",
        "documentation": {}
    },
    {
        "label": "JSONDeserializer",
        "importPath": "sagemaker.deserializers",
        "description": "sagemaker.deserializers",
        "isExtraImport": true,
        "detail": "sagemaker.deserializers",
        "documentation": {}
    },
    {
        "label": "JumpStartModel",
        "importPath": "sagemaker.jumpstart.model",
        "description": "sagemaker.jumpstart.model",
        "isExtraImport": true,
        "detail": "sagemaker.jumpstart.model",
        "documentation": {}
    },
    {
        "label": "JumpStartModel",
        "importPath": "sagemaker.jumpstart.model",
        "description": "sagemaker.jumpstart.model",
        "isExtraImport": true,
        "detail": "sagemaker.jumpstart.model",
        "documentation": {}
    },
    {
        "label": "HuggingFaceModel",
        "importPath": "sagemaker.huggingface",
        "description": "sagemaker.huggingface",
        "isExtraImport": true,
        "detail": "sagemaker.huggingface",
        "documentation": {}
    },
    {
        "label": "get_huggingface_llm_image_uri",
        "importPath": "sagemaker.huggingface",
        "description": "sagemaker.huggingface",
        "isExtraImport": true,
        "detail": "sagemaker.huggingface",
        "documentation": {}
    },
    {
        "label": "HuggingFaceModel",
        "importPath": "sagemaker.huggingface",
        "description": "sagemaker.huggingface",
        "isExtraImport": true,
        "detail": "sagemaker.huggingface",
        "documentation": {}
    },
    {
        "label": "get_huggingface_llm_image_uri",
        "importPath": "sagemaker.huggingface",
        "description": "sagemaker.huggingface",
        "isExtraImport": true,
        "detail": "sagemaker.huggingface",
        "documentation": {}
    },
    {
        "label": "sagemaker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sagemaker",
        "description": "sagemaker",
        "detail": "sagemaker",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "RagasEvaluator",
        "importPath": "core.eval.ragas.ragas_eval",
        "description": "core.eval.ragas.ragas_eval",
        "isExtraImport": true,
        "detail": "core.eval.ragas.ragas_eval",
        "documentation": {}
    },
    {
        "label": "RagasEvaluator",
        "importPath": "core.eval.ragas.ragas_eval",
        "description": "core.eval.ragas.ragas_eval",
        "isExtraImport": true,
        "detail": "core.eval.ragas.ragas_eval",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "ragas",
        "description": "ragas",
        "isExtraImport": true,
        "detail": "ragas",
        "documentation": {}
    },
    {
        "label": "SingleTurnSample",
        "importPath": "ragas.dataset_schema",
        "description": "ragas.dataset_schema",
        "isExtraImport": true,
        "detail": "ragas.dataset_schema",
        "documentation": {}
    },
    {
        "label": "EvaluationDataset",
        "importPath": "ragas.dataset_schema",
        "description": "ragas.dataset_schema",
        "isExtraImport": true,
        "detail": "ragas.dataset_schema",
        "documentation": {}
    },
    {
        "label": "SingleTurnSample",
        "importPath": "ragas.dataset_schema",
        "description": "ragas.dataset_schema",
        "isExtraImport": true,
        "detail": "ragas.dataset_schema",
        "documentation": {}
    },
    {
        "label": "NonLLMStringSimilarity",
        "importPath": "ragas.metrics._string",
        "description": "ragas.metrics._string",
        "isExtraImport": true,
        "detail": "ragas.metrics._string",
        "documentation": {}
    },
    {
        "label": "Faithfulness",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "AspectCritic",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "LLMContextPrecisionWithoutReference",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "ResponseRelevancy",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "LLMContextPrecisionWithReference",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "NonLLMStringSimilarity",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "NonLLMContextRecall",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "NonLLMContextPrecisionWithReference",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "RougeScore",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "BleuScore",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "Faithfulness",
        "importPath": "ragas.metrics",
        "description": "ragas.metrics",
        "isExtraImport": true,
        "detail": "ragas.metrics",
        "documentation": {}
    },
    {
        "label": "ChatBedrockConverse",
        "importPath": "langchain_aws",
        "description": "langchain_aws",
        "isExtraImport": true,
        "detail": "langchain_aws",
        "documentation": {}
    },
    {
        "label": "BedrockEmbeddings",
        "importPath": "langchain_aws",
        "description": "langchain_aws",
        "isExtraImport": true,
        "detail": "langchain_aws",
        "documentation": {}
    },
    {
        "label": "LangchainEmbeddingsWrapper",
        "importPath": "ragas.embeddings",
        "description": "ragas.embeddings",
        "isExtraImport": true,
        "detail": "ragas.embeddings",
        "documentation": {}
    },
    {
        "label": "LangchainLLMWrapper",
        "importPath": "ragas.llms",
        "description": "ragas.llms",
        "isExtraImport": true,
        "detail": "ragas.llms",
        "documentation": {}
    },
    {
        "label": "EvalFactory",
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "isExtraImport": true,
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "EvalFactory",
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "isExtraImport": true,
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "EvalFactory",
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "isExtraImport": true,
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "boto3,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "boto3.",
        "description": "boto3.",
        "detail": "boto3.",
        "documentation": {}
    },
    {
        "label": "InferencerFactory",
        "importPath": "core.inference.inference_factory",
        "description": "core.inference.inference_factory",
        "isExtraImport": true,
        "detail": "core.inference.inference_factory",
        "documentation": {}
    },
    {
        "label": "InferencerFactory",
        "importPath": "core.inference.inference_factory",
        "description": "core.inference.inference_factory",
        "isExtraImport": true,
        "detail": "core.inference.inference_factory",
        "documentation": {}
    },
    {
        "label": "FixedChunker",
        "importPath": "core.chunking",
        "description": "core.chunking",
        "isExtraImport": true,
        "detail": "core.chunking",
        "documentation": {}
    },
    {
        "label": "HierarchicalChunker",
        "importPath": "core.chunking",
        "description": "core.chunking",
        "isExtraImport": true,
        "detail": "core.chunking",
        "documentation": {}
    },
    {
        "label": "InferencerFactory",
        "importPath": "core.inference",
        "description": "core.inference",
        "isExtraImport": true,
        "detail": "core.inference",
        "documentation": {}
    },
    {
        "label": "deserialize_dynamodb_json",
        "importPath": "util.dynamo_utils",
        "description": "util.dynamo_utils",
        "isExtraImport": true,
        "detail": "util.dynamo_utils",
        "documentation": {}
    },
    {
        "label": "deserialize_dynamodb_json",
        "importPath": "util.dynamo_utils",
        "description": "util.dynamo_utils",
        "isExtraImport": true,
        "detail": "util.dynamo_utils",
        "documentation": {}
    },
    {
        "label": "deserialize_dynamodb_json",
        "importPath": "util.dynamo_utils",
        "description": "util.dynamo_utils",
        "isExtraImport": true,
        "detail": "util.dynamo_utils",
        "documentation": {}
    },
    {
        "label": "traceback,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback.",
        "description": "traceback.",
        "detail": "traceback.",
        "documentation": {}
    },
    {
        "label": "uuid",
        "importPath": "botocore.endpoint",
        "description": "botocore.endpoint",
        "isExtraImport": true,
        "detail": "botocore.endpoint",
        "documentation": {}
    },
    {
        "label": "OpenSearch",
        "importPath": "opensearchpy",
        "description": "opensearchpy",
        "isExtraImport": true,
        "detail": "opensearchpy",
        "documentation": {}
    },
    {
        "label": "RequestsHttpConnection",
        "importPath": "opensearchpy",
        "description": "opensearchpy",
        "isExtraImport": true,
        "detail": "opensearchpy",
        "documentation": {}
    },
    {
        "label": "AWSV4SignerAuth",
        "importPath": "opensearchpy",
        "description": "opensearchpy",
        "isExtraImport": true,
        "detail": "opensearchpy",
        "documentation": {}
    },
    {
        "label": "EvalProcessor",
        "importPath": "core.processors",
        "description": "core.processors",
        "isExtraImport": true,
        "detail": "core.processors",
        "documentation": {}
    },
    {
        "label": "ChunkingProcessor",
        "importPath": "core.processors",
        "description": "core.processors",
        "isExtraImport": true,
        "detail": "core.processors",
        "documentation": {}
    },
    {
        "label": "EmbedProcessor",
        "importPath": "core.processors",
        "description": "core.processors",
        "isExtraImport": true,
        "detail": "core.processors",
        "documentation": {}
    },
    {
        "label": "EmbedProcessor",
        "importPath": "core.processors",
        "description": "core.processors",
        "isExtraImport": true,
        "detail": "core.processors",
        "documentation": {}
    },
    {
        "label": "InferenceProcessor",
        "importPath": "core.processors",
        "description": "core.processors",
        "isExtraImport": true,
        "detail": "core.processors",
        "documentation": {}
    },
    {
        "label": "FargateTaskProcessor",
        "importPath": "task_processor",
        "description": "task_processor",
        "isExtraImport": true,
        "detail": "task_processor",
        "documentation": {}
    },
    {
        "label": "FargateTaskProcessor",
        "importPath": "task_processor",
        "description": "task_processor",
        "isExtraImport": true,
        "detail": "task_processor",
        "documentation": {}
    },
    {
        "label": "FargateTaskProcessor",
        "importPath": "task_processor",
        "description": "task_processor",
        "isExtraImport": true,
        "detail": "task_processor",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfigService",
        "importPath": "core.service.experimental_config_service",
        "description": "core.service.experimental_config_service",
        "isExtraImport": true,
        "detail": "core.service.experimental_config_service",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfigService",
        "importPath": "core.service.experimental_config_service",
        "description": "core.service.experimental_config_service",
        "isExtraImport": true,
        "detail": "core.service.experimental_config_service",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfigService",
        "importPath": "core.service.experimental_config_service",
        "description": "core.service.experimental_config_service",
        "isExtraImport": true,
        "detail": "core.service.experimental_config_service",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluation.eval",
        "description": "evaluation.eval",
        "isExtraImport": true,
        "detail": "evaluation.eval",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "evaluation.eval",
        "description": "evaluation.eval",
        "isExtraImport": true,
        "detail": "evaluation.eval",
        "documentation": {}
    },
    {
        "label": "chunk_embed_store",
        "importPath": "indexing.indexing",
        "description": "indexing.indexing",
        "isExtraImport": true,
        "detail": "indexing.indexing",
        "documentation": {}
    },
    {
        "label": "chunk_embed_store",
        "importPath": "indexing.indexing",
        "description": "indexing.indexing",
        "isExtraImport": true,
        "detail": "indexing.indexing",
        "documentation": {}
    },
    {
        "label": "retrieve",
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "isExtraImport": true,
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "retrieve",
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "isExtraImport": true,
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "OpenSearchVectorDatabase",
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "isExtraImport": true,
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "OpenSearchVectorDatabase",
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "isExtraImport": true,
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "OpenSearchVectorDatabase",
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "isExtraImport": true,
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "OpenSearchVectorDatabase",
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "isExtraImport": true,
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "bulk",
        "importPath": "opensearchpy.helpers",
        "description": "opensearchpy.helpers",
        "isExtraImport": true,
        "detail": "opensearchpy.helpers",
        "documentation": {}
    },
    {
        "label": "compute_actual_price_breakdown",
        "importPath": "pricing",
        "description": "pricing",
        "isExtraImport": true,
        "detail": "pricing",
        "documentation": {}
    },
    {
        "label": "calculate_experiment_duration",
        "importPath": "pricing",
        "description": "pricing",
        "isExtraImport": true,
        "detail": "pricing",
        "documentation": {}
    },
    {
        "label": "convert_floats_to_decimal",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_csv_from_s3",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "parse_datetime",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "OpenSearchIndexManager",
        "importPath": "opensearch.opensearch_index_manager",
        "description": "opensearch.opensearch_index_manager",
        "isExtraImport": true,
        "detail": "opensearch.opensearch_index_manager",
        "documentation": {}
    },
    {
        "label": "BedrockGuardrails",
        "importPath": "core.guardrails.bedrock_guardrails",
        "description": "core.guardrails.bedrock_guardrails",
        "isExtraImport": true,
        "detail": "core.guardrails.bedrock_guardrails",
        "documentation": {}
    },
    {
        "label": "DocumentReranker",
        "importPath": "core.rerank.rerank",
        "description": "core.rerank.rerank",
        "isExtraImport": true,
        "detail": "core.rerank.rerank",
        "documentation": {}
    },
    {
        "label": "KnowledgeBaseVectorDatabase",
        "importPath": "core.knowledgebase_vectorstore",
        "description": "core.knowledgebase_vectorstore",
        "isExtraImport": true,
        "detail": "core.knowledgebase_vectorstore",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "fitz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fitz",
        "description": "fitz",
        "detail": "fitz",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.common.logger",
        "description": "app.common.logger",
        "peekOfCode": "logger = logging.getLogger(__name__)",
        "detail": "app.common.logger",
        "documentation": {}
    },
    {
        "label": "Database",
        "kind": 6,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "class Database:\n    def __init__(self):\n        self.config = get_config()\n        self.execution_db = None\n        self.experiment_db = None\n        self.question_metrics_db = None\n        self.execution_model_invocations_db = None\n        self.step_function_orchestrator = None\n    def initialize(self):\n        \"\"\"Initialize all database connections and services\"\"\"",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_execution_db",
        "kind": 2,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "def get_execution_db() -> DynamoDBOperations:\n    return db.execution_db\ndef get_experiment_db() -> DynamoDBOperations:\n    return db.experiment_db\ndef get_question_metrics_db() -> DynamoDBOperations:\n    return db.question_metrics_db\ndef get_execution_model_invocations_db() -> DynamoDBOperations:\n    return db.execution_model_invocations_db\ndef get_step_function_orchestrator() -> StepFunctionOrchestrator:\n    return db.step_function_orchestrator",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_experiment_db",
        "kind": 2,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "def get_experiment_db() -> DynamoDBOperations:\n    return db.experiment_db\ndef get_question_metrics_db() -> DynamoDBOperations:\n    return db.question_metrics_db\ndef get_execution_model_invocations_db() -> DynamoDBOperations:\n    return db.execution_model_invocations_db\ndef get_step_function_orchestrator() -> StepFunctionOrchestrator:\n    return db.step_function_orchestrator",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_question_metrics_db",
        "kind": 2,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "def get_question_metrics_db() -> DynamoDBOperations:\n    return db.question_metrics_db\ndef get_execution_model_invocations_db() -> DynamoDBOperations:\n    return db.execution_model_invocations_db\ndef get_step_function_orchestrator() -> StepFunctionOrchestrator:\n    return db.step_function_orchestrator",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_execution_model_invocations_db",
        "kind": 2,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "def get_execution_model_invocations_db() -> DynamoDBOperations:\n    return db.execution_model_invocations_db\ndef get_step_function_orchestrator() -> StepFunctionOrchestrator:\n    return db.step_function_orchestrator",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_step_function_orchestrator",
        "kind": 2,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "def get_step_function_orchestrator() -> StepFunctionOrchestrator:\n    return db.step_function_orchestrator",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "app.dependencies.database",
        "description": "app.dependencies.database",
        "peekOfCode": "db = Database()\n# Dependency functions\ndef get_execution_db() -> DynamoDBOperations:\n    return db.execution_db\ndef get_experiment_db() -> DynamoDBOperations:\n    return db.experiment_db\ndef get_question_metrics_db() -> DynamoDBOperations:\n    return db.question_metrics_db\ndef get_execution_model_invocations_db() -> DynamoDBOperations:\n    return db.execution_model_invocations_db",
        "detail": "app.dependencies.database",
        "documentation": {}
    },
    {
        "label": "get_s3_client",
        "kind": 2,
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "peekOfCode": "def get_s3_client() -> boto3.client:\n    return s3",
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "peekOfCode": "config = get_config()\n# Create global S3 client\nS3_BUCKET = config.s3_bucket\ns3 = boto3.client('s3', config=Config(signature_version='s3v4'))\ndef get_s3_client() -> boto3.client:\n    return s3",
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "kind": 5,
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "peekOfCode": "S3_BUCKET = config.s3_bucket\ns3 = boto3.client('s3', config=Config(signature_version='s3v4'))\ndef get_s3_client() -> boto3.client:\n    return s3",
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "s3",
        "kind": 5,
        "importPath": "app.dependencies.s3",
        "description": "app.dependencies.s3",
        "peekOfCode": "s3 = boto3.client('s3', config=Config(signature_version='s3v4'))\ndef get_s3_client() -> boto3.client:\n    return s3",
        "detail": "app.dependencies.s3",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.bedrock_config",
        "description": "app.routes.bedrock_config",
        "peekOfCode": "router = APIRouter()\n@router.get(\"/bedrock/guardrails\", tags=[\"bedrock\"])\nasync def health_check(region: Optional[str] = Query('us-east-1', description=\"AWS region to list guardrails from\")):\n    \"Endpoint to list Bedrock guardrails.\"\n    try:\n        response = GuardRailsUtils.get_bedrock_guardrails(region)\n        return response\n    except Exception as e:\n        raise HTTPException(status_code=StatusCodes.INTERNAL_SERVER_ERROR, detail=str(e))\n@router.get(\"/bedrock/knowledge_bases\", tags=[\"bedrock\"])",
        "detail": "app.routes.bedrock_config",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.config",
        "description": "app.routes.config",
        "peekOfCode": "router = APIRouter()\n@router.get(\"/config\", tags=[\"config\"])\nasync def config():\n    return {\n        \"opensearch\": OpenSearchUtils.opensearch_config()\n    }",
        "detail": "app.routes.config",
        "documentation": {}
    },
    {
        "label": "calculate_experiment_duration",
        "kind": 2,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "def calculate_experiment_duration(experiment):\n    try:\n        # Initialize total duration\n        total_duration = 0\n        # Calculate indexing duration if fields are present\n        if experiment.get('indexing_start') and experiment.get('indexing_end'):\n            indexing_start = DateTimeUtils.parse_datetime(experiment.get('indexing_start'))\n            indexing_end = DateTimeUtils.parse_datetime(experiment.get('indexing_end'))\n            indexing_difference = indexing_end - indexing_start\n            total_duration += indexing_difference.total_seconds()",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "calculate_experiment_cost",
        "kind": 2,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "def calculate_experiment_cost(experiment, num_tokens_kb_data, avg_promopt_length, num_prompts, os_price):\n    try:\n        cost = 0\n        if experiment['config']['embedding_service'] == \"bedrock\":\n            embedding_price = estimate_embedding_model_bedrock_price(bedrock_price_df, experiment['config'],\n                                                                     num_tokens_kb_data)\n            cost += embedding_price\n        else:\n            cost += estimate_sagemaker_price()\n        if experiment['config'][\"retrieval_service\"] == \"bedrock\":",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "calculate_duration",
        "kind": 2,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "def calculate_duration(response):\n    try:\n        final_response = []\n        for each_item in response:\n            if 'experiment_status' in each_item and each_item['experiment_status'] in ['succeeded','failed']:\n                each_item['total_time'] = calculate_experiment_duration(each_item)\n            else:\n                each_item['total_time'] = 0\n            final_response.append(each_item)\n        return final_response",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "calculate_cost",
        "kind": 2,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "def calculate_cost(response):\n    try:\n        final_response = []\n        os_price = estimate_opensearch_price()\n        if response:\n            num_tokens_kb_data = count_characters_in_file(response[0]['config'][\"kb_data\"]) / 4\n            gt_data = response[0]['config'][\"gt_data\"]\n            [num_prompts, num_chars] = read_gt_data(gt_data)\n            avg_promopt_length = round(num_chars / num_prompts / 4)\n            for each_item in response:",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "configs",
        "kind": 5,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "configs = get_config()\nS3_BUCKET = configs.s3_bucket\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nfrom app.price_calculator import estimate_opensearch_price, estimate_sagemaker_price, estimate_embedding_model_bedrock_price, estimate_retrieval_model_bedrock_price\nfrom app.configuration_validation import read_gt_data, count_characters_in_file\ndef calculate_experiment_duration(experiment):\n    try:\n        # Initialize total duration\n        total_duration = 0\n        # Calculate indexing duration if fields are present",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "kind": 5,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "S3_BUCKET = configs.s3_bucket\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nfrom app.price_calculator import estimate_opensearch_price, estimate_sagemaker_price, estimate_embedding_model_bedrock_price, estimate_retrieval_model_bedrock_price\nfrom app.configuration_validation import read_gt_data, count_characters_in_file\ndef calculate_experiment_duration(experiment):\n    try:\n        # Initialize total duration\n        total_duration = 0\n        # Calculate indexing duration if fields are present\n        if experiment.get('indexing_start') and experiment.get('indexing_end'):",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "bedrock_price_df",
        "kind": 5,
        "importPath": "app.routes.cost_and_duration_calculation",
        "description": "app.routes.cost_and_duration_calculation",
        "peekOfCode": "bedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nfrom app.price_calculator import estimate_opensearch_price, estimate_sagemaker_price, estimate_embedding_model_bedrock_price, estimate_retrieval_model_bedrock_price\nfrom app.configuration_validation import read_gt_data, count_characters_in_file\ndef calculate_experiment_duration(experiment):\n    try:\n        # Initialize total duration\n        total_duration = 0\n        # Calculate indexing duration if fields are present\n        if experiment.get('indexing_start') and experiment.get('indexing_end'):\n            indexing_start = DateTimeUtils.parse_datetime(experiment.get('indexing_start'))",
        "detail": "app.routes.cost_and_duration_calculation",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.execution",
        "description": "app.routes.execution",
        "peekOfCode": "router = APIRouter(tags=[\"execution\"])\nconfig = get_config()\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"Execution\")\n@router.post(\"/execution\")\nasync def post_execution(\n        payload: dict,\n        status: Optional[str] = None,\n        execution_db=Depends(get_execution_db)",
        "detail": "app.routes.execution",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "app.routes.execution",
        "description": "app.routes.execution",
        "peekOfCode": "config = get_config()\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"Execution\")\n@router.post(\"/execution\")\nasync def post_execution(\n        payload: dict,\n        status: Optional[str] = None,\n        execution_db=Depends(get_execution_db)\n):",
        "detail": "app.routes.execution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.execution",
        "description": "app.routes.execution",
        "peekOfCode": "logger = logging.getLogger(\"Execution\")\n@router.post(\"/execution\")\nasync def post_execution(\n        payload: dict,\n        status: Optional[str] = None,\n        execution_db=Depends(get_execution_db)\n):\n    \"\"\"\n    Create a new execution, ensuring no other execution is currently in progress.\n    Args:",
        "detail": "app.routes.execution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.experiment",
        "description": "app.routes.experiment",
        "peekOfCode": "logger = logging.getLogger(\"Execution\")\nrouter = APIRouter(tags=[\"experiment\"])\n@router.post(\"/execution/{execution_id}/experiment\")\nasync def post_experiment(\n        execution_id: str,\n        experiments: List[dict],\n        status: Optional[str] = None,\n        experiment_db: DynamoDBOperations=Depends(get_experiment_db),\n        execution_db: DynamoDBOperations=Depends(get_execution_db)\n):",
        "detail": "app.routes.experiment",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.experiment",
        "description": "app.routes.experiment",
        "peekOfCode": "router = APIRouter(tags=[\"experiment\"])\n@router.post(\"/execution/{execution_id}/experiment\")\nasync def post_experiment(\n        execution_id: str,\n        experiments: List[dict],\n        status: Optional[str] = None,\n        experiment_db: DynamoDBOperations=Depends(get_experiment_db),\n        execution_db: DynamoDBOperations=Depends(get_execution_db)\n):\n    \"\"\"",
        "detail": "app.routes.experiment",
        "documentation": {}
    },
    {
        "label": "ExperimentQuery",
        "kind": 6,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "class ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"\n    Calculate the cost of model inference for a given number of input and output tokens.\n    Args:\n        file_path: DataFrame containing pricing information",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "VotePayload",
        "kind": 6,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "class VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"\n    Calculate the cost of model inference for a given number of input and output tokens.\n    Args:\n        file_path: DataFrame containing pricing information\n        model: Name of the model being used\n        input_tokens: Number of input tokens\n        output_tokens: Number of output tokens  ",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "get_model_question_prices",
        "kind": 2,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "def get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"\n    Calculate the cost of model inference for a given number of input and output tokens.\n    Args:\n        file_path: DataFrame containing pricing information\n        model: Name of the model being used\n        input_tokens: Number of input tokens\n        output_tokens: Number of output tokens  \n        region: AWS region\n    Returns:",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "get_experiment_db",
        "kind": 2,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "def get_experiment_db():\n    return DynamoDB(config.get_experiment_table_name())\ndef get_experiment_configs(experiment_db: DynamoDB, experiment_ids: List[str]) -> List[Dict]:\n    \"\"\"\n    Get the experiment configs for all experiments using their IDs.\n    Args:\n        experiment_db: Instance of DynamoDB.\n        experiment_ids (List[str]): List of experiment IDs.\n    Returns:\n        List[Dict]: List of JSON objects for each experiment.",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "get_experiment_configs",
        "kind": 2,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "def get_experiment_configs(experiment_db: DynamoDB, experiment_ids: List[str]) -> List[Dict]:\n    \"\"\"\n    Get the experiment configs for all experiments using their IDs.\n    Args:\n        experiment_db: Instance of DynamoDB.\n        experiment_ids (List[str]): List of experiment IDs.\n    Returns:\n        List[Dict]: List of JSON objects for each experiment.\n    \"\"\"\n    experiments = []",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "env_config_provider",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "env_config_provider = EnvConfigProvider()\nconfig = Config(env_config_provider)\nconfigs = get_config()\nS3_BUCKET = configs.s3_bucket\nlogger = logging.getLogger(__name__)\nrouter = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "config = Config(env_config_provider)\nconfigs = get_config()\nS3_BUCKET = configs.s3_bucket\nlogger = logging.getLogger(__name__)\nrouter = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "configs",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "configs = get_config()\nS3_BUCKET = configs.s3_bucket\nlogger = logging.getLogger(__name__)\nrouter = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "S3_BUCKET = configs.s3_bucket\nlogger = logging.getLogger(__name__)\nrouter = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "logger = logging.getLogger(__name__)\nrouter = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "router = APIRouter()\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"\n    Calculate the cost of model inference for a given number of input and output tokens.",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "bedrock_price_df",
        "kind": 5,
        "importPath": "app.routes.expert_eval",
        "description": "app.routes.expert_eval",
        "peekOfCode": "bedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\nclass ExperimentQuery(BaseModel):\n    experiment_ids: List[str]\n    query: str\nclass VotePayload(RootModel):\n    root: Dict[str, int]\ndef get_model_question_prices(file_path, model, input_tokens, output_tokens, region):\n    \"\"\"\n    Calculate the cost of model inference for a given number of input and output tokens.\n    Args:",
        "detail": "app.routes.expert_eval",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.health",
        "description": "app.routes.health",
        "peekOfCode": "router = APIRouter()\n@router.get(\"/health\", tags=[\"health\"])\nasync def health_check():\n    return {\"status\": \"healthy\"}",
        "detail": "app.routes.health",
        "documentation": {}
    },
    {
        "label": "PresignedurlRequestKB",
        "kind": 6,
        "importPath": "app.routes.uploads",
        "description": "app.routes.uploads",
        "peekOfCode": "class PresignedurlRequestKB(BaseModel):\n    unique_id: str\n    files: List[str]\nclass PresignedurlRequestGT(BaseModel):\n    unique_id: str\n@router.post(\"/presignedurl\", tags=[\"uploads\"])\nasync def get_presigned_url(\n    request: PresignedurlRequestGT, \n    s3=Depends(get_s3_client)\n):",
        "detail": "app.routes.uploads",
        "documentation": {}
    },
    {
        "label": "PresignedurlRequestGT",
        "kind": 6,
        "importPath": "app.routes.uploads",
        "description": "app.routes.uploads",
        "peekOfCode": "class PresignedurlRequestGT(BaseModel):\n    unique_id: str\n@router.post(\"/presignedurl\", tags=[\"uploads\"])\nasync def get_presigned_url(\n    request: PresignedurlRequestGT, \n    s3=Depends(get_s3_client)\n):\n    unique_id = request.unique_id\n    ground_truth_data_key = f\"{unique_id}/gt_data/gt.json\"\n    gt_data_path = f\"s3://{S3_BUCKET}/{ground_truth_data_key}\"",
        "detail": "app.routes.uploads",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.routes.uploads",
        "description": "app.routes.uploads",
        "peekOfCode": "logger = logging.getLogger(__name__)\nrouter = APIRouter()\nclass PresignedurlRequestKB(BaseModel):\n    unique_id: str\n    files: List[str]\nclass PresignedurlRequestGT(BaseModel):\n    unique_id: str\n@router.post(\"/presignedurl\", tags=[\"uploads\"])\nasync def get_presigned_url(\n    request: PresignedurlRequestGT, ",
        "detail": "app.routes.uploads",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routes.uploads",
        "description": "app.routes.uploads",
        "peekOfCode": "router = APIRouter()\nclass PresignedurlRequestKB(BaseModel):\n    unique_id: str\n    files: List[str]\nclass PresignedurlRequestGT(BaseModel):\n    unique_id: str\n@router.post(\"/presignedurl\", tags=[\"uploads\"])\nasync def get_presigned_url(\n    request: PresignedurlRequestGT, \n    s3=Depends(get_s3_client)",
        "detail": "app.routes.uploads",
        "documentation": {}
    },
    {
        "label": "is_valid_combination",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def is_valid_combination(config, data):\n    # Define your rules here\n    regions = [\"us-east-1\", \"us-west-2\"]\n    if config['bedrock_knowledge_base'] or not config['knowledge_base']:\n        return True\n    if config[\"region\"] not in regions:\n        return False\n    if config[\"n_shot_prompts\"] > 0 and data[\"n_shot_prompt_guide\"] is None:\n        return False\n    if config['embedding'][\"service\"] == \"bedrock\" and config[\"embedding\"][\"model\"] == \"amazon.titan-embed-image-v1\":",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "parse_dynamodb",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def parse_dynamodb(item):\n    if isinstance(item, dict):\n        if \"M\" in item:\n            return {k: parse_dynamodb(v) for k, v in item[\"M\"].items()}\n        elif \"L\" in item:\n            return [parse_dynamodb(v) for v in item[\"L\"]]\n        elif \"S\" in item:\n            return item[\"S\"]\n        elif \"N\" in item:\n            return float(item[\"N\"]) if \".\" in item[\"N\"] else int(item[\"N\"])",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "flatten_parameters",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def flatten_parameters(stage_data):\n    flattened = {}\n    for key, value in stage_data.items():\n        if isinstance(value, list):\n            flattened[key] = value\n        else:\n            flattened[key] = [value]\n    return flattened\ndef restructure_combination(combination):\n    # Define the expected structure",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "restructure_combination",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def restructure_combination(combination):\n    # Define the expected structure\n    result = {}\n    # Prestep keys\n    prestep_keys = ['region', 'gt_data', 'kb_data']\n    for key in prestep_keys:\n        if key in combination:\n            result[key] = combination[key]\n    # Indexing keys\n    indexing_keys = [",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "count_characters_in_file",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def count_characters_in_file(file_path):\n    file_path = S3Util().download_directory_from_s3(file_path)\n    character_counts = 0\n    try:\n        for file in os.listdir(file_path):\n            full_file = os.path.join(file_path, file)\n            if file.endswith('.txt'):\n                with open(full_file, 'r') as file:\n                    content = file.read()\n                    character_counts+= len(content)",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "read_gt_data",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def read_gt_data(file_path):\n    \"\"\"\n    Reads a GT-data file and outputs the number of JSON entries and the total number of characters in the file.\n    Parameters:\n    file_path (str): The path to the GT-data file.\n    Returns:\n    tuple: A tuple containing the number of JSON entries and the total number of characters in the file.\n    \"\"\"\n    try:\n        json_entries, data = S3Util().read_json_and_content_from_s3(file_path)",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "remove_invalid_combinations_keys",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def remove_invalid_combinations_keys(combinations):\n    \"\"\"\n    Adjusts combinations to set irrelevant keys to None based on the value of 'chunking_strategy'.\n    Parameters:\n        combinations: List of combinations.\n    Returns:\n        list of dict: Updated combinations with irrelevant keys set to None.\n    \"\"\"\n    for combination in combinations:\n        if combination.get(\"chunking_strategy\", None) == \"fixed\":",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "unpack_knowledebases",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def unpack_knowledebases(combinations):\n    for combination in combinations:\n        kb_data = combination.get('kb_data')\n        if isinstance(kb_data, dict):\n            combination[\"kb_name\"] = kb_data.get(\"name\", \"\")\n            combination[\"kb_data\"] = kb_data.get(\"id\", \"\")\n        elif isinstance(kb_data, str):\n            combination[\"kb_data\"] = kb_data\n            combination[\"kb_name\"] = \"\"\n    return combinations",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "unpack_guardrails",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def unpack_guardrails(combinations):\n    for combination in combinations:\n        combination[\"enable_guardrails\"] = True if \"guardrails\" in combination else False\n        combination[\"guardrail_id\"] = combination.get(\"guardrails\", {}).get(\"guardrails_id\", \"\")\n        combination[\"guardrail_name\"] = combination.get(\"guardrails\", {}).get(\"name\", \"\")\n        combination[\"guardrail_version\"] = combination.get(\"guardrails\", {}).get(\"guardrail_version\", \"\")\n        combination[\"enable_prompt_guardrails\"] = combination.get(\"guardrails\", {}).get(\"enable_prompt_guardrails\", False)\n        combination[\"enable_context_guardrails\"] = combination.get(\"guardrails\", {}).get(\"enable_context_guardrails\", False)\n        combination[\"enable_response_guardrails\"] = combination.get(\"guardrails\", {}).get(\"enable_response_guardrails\", False)\n        if \"guardrails\" in combination:",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "add_kb_info",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def add_kb_info(parameters_all):\n    if 'kb_data' in parameters_all:\n        if parameters_all['bedrock_knowledge_base']:\n            kb_ids = parameters_all['kb_data']\n            kb_data = []\n            for kb_id in kb_ids:\n                kb_name = KnowledgeBaseUtils(parameters_all['region']).get_kb_name(kb_id)\n                kb_data.append({\n                    \"id\": kb_id,\n                    \"name\": kb_name",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "generate_all_combinations",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def generate_all_combinations(data):\n    # Parse the DynamoDB-style JSON\n    parsed_data = {k: parse_dynamodb(v) for k, v in data.items()}\n    parameters_all = parsed_data[\"prestep\"]\n    parameters_all.update(parsed_data[\"indexing\"])\n    parameters_all.update(parsed_data[\"retrieval\"])\n    if \"guardrails\" in parsed_data and parsed_data[\"guardrails\"]:\n        parameters_all.update({\"guardrails\": parsed_data[\"guardrails\"]})\n    parameters_all.update(parsed_data[\"evaluation\"])\n    parameters_all = add_kb_info(parameters_all)",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "generate_all_combinations_in_background",
        "kind": 2,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "def generate_all_combinations_in_background(execution_id: str, execution_config_data):\n    \"\"\"       \n    Generate all possible valid experiment configurations for a given execution and stores result in S3.\n    Progress status and result s3 url is stored in execution db under valid execution_id\n    \"\"\"\n    try:\n        # update status of execution_id to InProgress\n        get_execution_db().update_item(\n            key={\"id\": execution_id}, \n            update_expression=\"SET validation_status = :status_value\", ",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "configs",
        "kind": 5,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "configs = get_config()\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nS3_BUCKET = configs.s3_bucket\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\ndef is_valid_combination(config, data):\n    # Define your rules here\n    regions = [\"us-east-1\", \"us-west-2\"]\n    if config['bedrock_knowledge_base'] or not config['knowledge_base']:\n        return True",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nS3_BUCKET = configs.s3_bucket\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\ndef is_valid_combination(config, data):\n    # Define your rules here\n    regions = [\"us-east-1\", \"us-west-2\"]\n    if config['bedrock_knowledge_base'] or not config['knowledge_base']:\n        return True\n    if config[\"region\"] not in regions:",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "kind": 5,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "S3_BUCKET = configs.s3_bucket\nbedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\ndef is_valid_combination(config, data):\n    # Define your rules here\n    regions = [\"us-east-1\", \"us-west-2\"]\n    if config['bedrock_knowledge_base'] or not config['knowledge_base']:\n        return True\n    if config[\"region\"] not in regions:\n        return False\n    if config[\"n_shot_prompts\"] > 0 and data[\"n_shot_prompt_guide\"] is None:",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "bedrock_price_df",
        "kind": 5,
        "importPath": "app.configuration_validation",
        "description": "app.configuration_validation",
        "peekOfCode": "bedrock_price_df = S3Util().read_csv_from_s3(configs.bedrock_limit_csv_path, S3_BUCKET, as_dataframe=True)\ndef is_valid_combination(config, data):\n    # Define your rules here\n    regions = [\"us-east-1\", \"us-west-2\"]\n    if config['bedrock_knowledge_base'] or not config['knowledge_base']:\n        return True\n    if config[\"region\"] not in regions:\n        return False\n    if config[\"n_shot_prompts\"] > 0 and data[\"n_shot_prompt_guide\"] is None:\n        return False",
        "detail": "app.configuration_validation",
        "documentation": {}
    },
    {
        "label": "create_app",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def create_app() -> FastAPI:\n    app = FastAPI(title=\"FloTorch Experiment API\")\n    # Initialize databases at startup\n    @app.on_event(\"startup\")\n    async def startup_event():\n        db.initialize()\n        seed_models(get_execution_model_invocations_db())\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "app = create_app()",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "ExperimentRequest",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class ExperimentRequest(BaseModel):\n    config: Dict\n    gt_data: str\n    kb_data: str\n    region: str\n    name: str\nclass ExperimentResponse(BaseModel):\n    status: str\n    experiment_ids: List[str]\nclass ExecutionResponse(BaseModel):",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "ExperimentResponse",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class ExperimentResponse(BaseModel):\n    status: str\n    experiment_ids: List[str]\nclass ExecutionResponse(BaseModel):\n    status: str\n    execution_id: str",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "ExecutionResponse",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class ExecutionResponse(BaseModel):\n    status: str\n    execution_id: str",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "StepFunctionOrchestrator",
        "kind": 6,
        "importPath": "app.orchestrator",
        "description": "app.orchestrator",
        "peekOfCode": "class StepFunctionOrchestrator:\n    \"\"\"\n    Handles Step Function orchestration for experiment execution.\n    \"\"\"\n    def __init__(self):\n        self.config = get_config()\n        self.step_function_client = self._initialize_step_function_client()\n    def _initialize_step_function_client(self) -> boto3.client:\n        \"\"\"\n        Initialize the AWS Step Function client.",
        "detail": "app.orchestrator",
        "documentation": {}
    },
    {
        "label": "run_experiment_orchestration",
        "kind": 2,
        "importPath": "app.orchestrator",
        "description": "app.orchestrator",
        "peekOfCode": "def run_experiment_orchestration(execution_id: str) -> Dict[str, Any]:\n    \"\"\"\n    Wrapper function for backward compatibility.\n    Args:\n        execution_id (str): The execution ID.\n    Returns:\n        Dict[str, Any]: Response from Step Function execution\n    \"\"\"\n    return orchestrator.run_experiment_orchestration(execution_id)",
        "detail": "app.orchestrator",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.orchestrator",
        "description": "app.orchestrator",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass StepFunctionOrchestrator:\n    \"\"\"\n    Handles Step Function orchestration for experiment execution.\n    \"\"\"\n    def __init__(self):\n        self.config = get_config()\n        self.step_function_client = self._initialize_step_function_client()\n    def _initialize_step_function_client(self) -> boto3.client:\n        \"\"\"",
        "detail": "app.orchestrator",
        "documentation": {}
    },
    {
        "label": "orchestrator",
        "kind": 5,
        "importPath": "app.orchestrator",
        "description": "app.orchestrator",
        "peekOfCode": "orchestrator = StepFunctionOrchestrator()\ndef run_experiment_orchestration(execution_id: str) -> Dict[str, Any]:\n    \"\"\"\n    Wrapper function for backward compatibility.\n    Args:\n        execution_id (str): The execution ID.\n    Returns:\n        Dict[str, Any]: Response from Step Function execution\n    \"\"\"\n    return orchestrator.run_experiment_orchestration(execution_id)",
        "detail": "app.orchestrator",
        "documentation": {}
    },
    {
        "label": "estimate_effective_kb_tokens",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_effective_kb_tokens(configuration, num_tokens_kb_data):\n    chunking_strategy = configuration[\"chunking_strategy\"].lower()\n    if chunking_strategy == 'fixed':\n        chunk_size = configuration[\"chunk_size\"]\n        chunk_overlap = configuration[\"chunk_overlap\"]\n        eff_chunk_size = chunk_size * (1 - chunk_overlap / 100)\n    elif chunking_strategy == 'hierarchical':\n        child_chunk_size = configuration[\"hierarchical_child_chunk_size\"]\n        child_chunk_overlap = configuration[\"hierarchical_chunk_overlap_percentage\"]\n        eff_chunk_size = child_chunk_size * (1 - child_chunk_overlap / 100)",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_embedding_model_bedrock_price",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_embedding_model_bedrock_price(file_path, configuration, effective_kb_tokens):\n    try:\n        df = file_path.copy()\n        # return df\n    except Exception as e:\n        logger.error(f\"Error reading the CSV file: {e}\")\n        return None\n    region = configuration[\"region\"]\n    embed_model = configuration[\"embedding_model\"]\n    embed_model_price = df[(df['model'] == embed_model) & (df['Region'] == region)]['input_price']",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_retrieval_model_bedrock_price",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_retrieval_model_bedrock_price(file_path, configuration, avg_prompt_length,\n                                           num_prompts):\n    try:\n        df = file_path.copy()\n        # return df\n    except Exception as e:\n        logger.error(f\"Error reading the CSV file: {e}\")\n        return None\n    region = configuration[\"region\"]\n    chunking_strategy = configuration[\"chunking_strategy\"].lower()",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_fargate_price",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_fargate_price(total_time, vpc=8, mem=16):\n    #Fargate pricing\n    fargate_cpu = 0.04048 \n    fargate_mem = 0.004445\n    fargate_cpu_price = fargate_cpu * vpc\n    fargate_mem_price = fargate_mem * mem\n    fargate_price = (fargate_cpu_price + fargate_mem_price) * total_time / 60\n    return fargate_price\ndef estimate_opensearch_price(time):\n    opensearch_instance_cost_per_hour = .711 # r7g.2xlarge.search",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_opensearch_price",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_opensearch_price(time):\n    opensearch_instance_cost_per_hour = .711 # r7g.2xlarge.search\n    num_instance = 3\n    instance_price =  opensearch_instance_cost_per_hour * num_instance #per hour\n    ebs_volume_size = 2\n    ebs_volume_size = 10\n    ebs_volume_price = .122\n    ebs_price = ebs_volume_price * ebs_volume_size * num_instance /30 /24 #3 instances for 2GB per hour\n    iops_price_per_hour = 13000  # instances per hour for 16000 IOPS (3000 free)\n    iops_price = iops_price_per_hour * .008 * num_instance /30/ 24 #3 instances",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_sagemaker_price",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_sagemaker_price(time, number_of_instances = 1):\n    sagemaker_price = 1.210 #per hour ml.g5.2xlarge per model\n    overall_cost = sagemaker_price * number_of_instances * (time / 60)\n    return overall_cost\ndef estimate_times(no_of_kb_tokens, num_prompts, configuration):\n    # For every 50,000 tokens of kb data and 50 prompts of gt data, estimated time in mins\n    estimated_time = {\n        \"indexing\": {\"sagemaker\" : 2, \"bedrock\" : 1},\n        \"retrieval\": {\"sagemaker\": 3, \"bedrock\": 3},\n        \"eval\": {\"sagemaker\": 13, \"bedrock\": 12}",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "estimate_times",
        "kind": 2,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "def estimate_times(no_of_kb_tokens, num_prompts, configuration):\n    # For every 50,000 tokens of kb data and 50 prompts of gt data, estimated time in mins\n    estimated_time = {\n        \"indexing\": {\"sagemaker\" : 2, \"bedrock\" : 1},\n        \"retrieval\": {\"sagemaker\": 3, \"bedrock\": 3},\n        \"eval\": {\"sagemaker\": 13, \"bedrock\": 12}\n    }\n    indexing_service = configuration['embedding_service']\n    retrieval_service = configuration['retrieval_service']\n    indexing_time = 0 if configuration[\"bedrock_knowledge_base\"] or not configuration[\"knowledge_base\"] else (no_of_kb_tokens/ 50000) * estimated_time['indexing'][indexing_service]",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.price_calculator",
        "description": "app.price_calculator",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\ndef estimate_effective_kb_tokens(configuration, num_tokens_kb_data):\n    chunking_strategy = configuration[\"chunking_strategy\"].lower()\n    if chunking_strategy == 'fixed':\n        chunk_size = configuration[\"chunk_size\"]\n        chunk_overlap = configuration[\"chunk_overlap\"]\n        eff_chunk_size = chunk_size * (1 - chunk_overlap / 100)\n    elif chunking_strategy == 'hierarchical':\n        child_chunk_size = configuration[\"hierarchical_child_chunk_size\"]",
        "detail": "app.price_calculator",
        "documentation": {}
    },
    {
        "label": "seed_models",
        "kind": 2,
        "importPath": "app.seed_data",
        "description": "app.seed_data",
        "peekOfCode": "def seed_models(execution_model_invocations_db) -> int:\n    \"\"\"\n    Seeds the models data into DynamoDB.\n    Args:\n        execution_model_invocations_db: DynamoDBOperations instance for the models table\n    Returns:\n        int: Number of models seeded\n    Raises:\n        Exception: If there's an error during seeding\n    \"\"\"",
        "detail": "app.seed_data",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "app.seed_data",
        "description": "app.seed_data",
        "peekOfCode": "logger = logging.getLogger(__name__)\nMODELS = {\n    \"bedrock_us.amazon.nova-lite-v1:0\": 35,\n    \"bedrock_us.amazon.nova-micro-v1:0\": 35,\n    \"bedrock_us.amazon.nova-pro-v1:0\": 12,\n    \"bedrock_amazon.titan-text-lite-v1\": 14,\n    \"bedrock_amazon.titan-text-express-v1\": 14,\n    \"bedrock_us.anthropic.claude-3-5-sonnet-20241022-v2:0\": 5,\n    \"bedrock_anthropic.claude-3-5-sonnet-20240620-v1:0\": 5,\n    \"bedrock_us.anthropic.claude-3-7-sonnet-20250219-v1:0\": 5,",
        "detail": "app.seed_data",
        "documentation": {}
    },
    {
        "label": "MODELS",
        "kind": 5,
        "importPath": "app.seed_data",
        "description": "app.seed_data",
        "peekOfCode": "MODELS = {\n    \"bedrock_us.amazon.nova-lite-v1:0\": 35,\n    \"bedrock_us.amazon.nova-micro-v1:0\": 35,\n    \"bedrock_us.amazon.nova-pro-v1:0\": 12,\n    \"bedrock_amazon.titan-text-lite-v1\": 14,\n    \"bedrock_amazon.titan-text-express-v1\": 14,\n    \"bedrock_us.anthropic.claude-3-5-sonnet-20241022-v2:0\": 5,\n    \"bedrock_anthropic.claude-3-5-sonnet-20240620-v1:0\": 5,\n    \"bedrock_us.anthropic.claude-3-7-sonnet-20250219-v1:0\": 5,\n    \"bedrock_us.anthropic.claude-3-5-haiku-20241022-v1:0\": 5,",
        "detail": "app.seed_data",
        "documentation": {}
    },
    {
        "label": "VectorDatabase",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class VectorDatabase(ABC):\n    @abstractmethod\n    def create_index(self, index_name: str, mapping: Dict[str, Any], algorithm: str) -> None:\n        \"\"\"Create a new index with the specified mapping and algorithm.\"\"\"\n        pass\n    @abstractmethod\n    def update_index(self, index_name: str, new_mapping: Dict[str, Any]) -> None:\n        \"\"\"Update an existing index with a new mapping.\"\"\"\n        pass\n    @abstractmethod",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseInferencer",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BaseInferencer(ABC):\n    # Added a new parameter `role_arn` as part of the SageMaker integration. \n    # The `_initialize_client` method has been commented out for now, \n    # and will be invoked within the respective inference classes when needed.\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str = 'us-east-1', role_arn: str = None):\n        self.model_id = model_id\n        self.region_name = region\n        self.experiment_config = experiment_config\n        self.role_arn = role_arn\n        # self._initialize_client()",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "ExperimentQuestionMetrics",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class ExperimentQuestionMetrics(BaseModel):\n    id : str = Field(default_factory=lambda: str(uuid.uuid4()), description=\"The unique identifier for the question\")\n    execution_id : str = Field(..., description=\"The execution id\")\n    experiment_id: str = Field(..., description=\"The unique identifier for the experiment\")\n    timestamp: datetime = Field(default_factory=datetime.now, description=\"The timestamp of the experiment\")\n    question: str = Field(..., description=\"The question that was asked\")\n    gt_answer: str = Field(..., description=\"The answer that was given\")\n    generated_answer: str = Field(default='', description=\"The answer that was generated\")\n    reference_contexts:  Optional[List[str]] = Field(..., description=\"The reference contexts retrieved from vectorstore\") \n    query_metadata: Optional[Dict[str, int]] = Field(..., description=\"The metadata during querying\")",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseChunker",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BaseChunker(ABC):\n    \"\"\"Abstract base class for chunking strategies.\"\"\"\n    def __init__(self, chunk_size: int, chunk_overlap: int) -> None:\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n    @abstractmethod\n    def chunk(self, text: str) -> List[str]:\n        \"\"\"Abstract method for chunking text.\"\"\"\n        pass\nclass BaseHierarchicalChunker(ABC):",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseHierarchicalChunker",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BaseHierarchicalChunker(ABC):\n    \"\"\"Abstract base class for chunking strategies.\"\"\"\n    def __init__(self, parent_chunk_size: int, child_chunk_size: int, chunk_overlap: int) -> None:\n        self.parent_chunk_size = parent_chunk_size\n        self.child_chunk_size = child_chunk_size\n        self.chunk_overlap = chunk_overlap\n    @abstractmethod\n    def chunk(self, text: str) -> List[List[str]]:\n        \"\"\"Abstract method for chunking text.\"\"\"\n        pass",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEmbedder",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BaseEmbedder(ABC):\n    \"\"\"Abstract base class for all embedders.\"\"\"\n    def __init__(self, model_id: str) -> None:\n        self.model_id = model_id\n    @abstractmethod\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        pass\n    @abstractmethod\n    def embed(self, text: str, dimensions: int = 256, normalize: bool = True) -> List[float]:\n        pass",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BaseEvaluator",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BaseEvaluator(ABC):\n    def __init__(self, config: Config, experimental_config: ExperimentalConfig) -> None:\n        self.config = config\n        self.experimental_config = experimental_config\n        self._initialize_dynamodb()\n    @abstractmethod\n    def _initialize_scorers(self) -> None:\n        \"\"\"Initialize the appropriate scorers\"\"\"\n        pass\n    @abstractmethod",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class Experiment(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    execution_id: str\n    start_datetime: datetime = Field(default_factory=datetime.now)\n    end_datetime: Optional[datetime] = None\n    config: Dict[str, Any]\n    experiment_status: str = \"not_started\"\n    index_status: str = \"not_started\"\n    retrieval_status: str = \"not_started\"\n    index_id: Optional[str] = None",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "Execution",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class Execution(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    date: datetime = Field(default_factory=datetime.now)\n    config: Dict[str, Any]\n    status: str = \"not_started\"\n    gt_data: str\n    kb_data: Union[str, List[str]]\n    region: str\n    name: str\n@dataclass",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "EvaluationMetrics",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class EvaluationMetrics():\n    faithfulness_score: Optional[float] = 0.0\n    context_precision_score: Optional[float] = 0.0\n    aspect_critic_score: Optional[float] = 0.0\n    answers_relevancy_score: Optional[float] = 0.0\n    string_similarity: Optional[float] = 0.0\n    context_recall: Optional[float] = 0.0\n    rouge_score: Optional[float] = 0.0\n    def from_dict(self, metrics_dict: Dict[str, str]) -> 'EvaluationMetrics':\n        \"\"\"Convert metrics from DynamoDB format to EvaluationMetrics\"\"\"",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "RetryParams",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class RetryParams(BaseModel):\n    max_retries: int\n    retry_delay: int\n    backoff_factor: int\nclass BotoRetryHandler(ABC):\n    \"\"\"Abstract class for retry handler\"\"\"\n    @property\n    @abstractmethod\n    def retry_params(self) -> RetryParams:\n        pass",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "BotoRetryHandler",
        "kind": 6,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "class BotoRetryHandler(ABC):\n    \"\"\"Abstract class for retry handler\"\"\"\n    @property\n    @abstractmethod\n    def retry_params(self) -> RetryParams:\n        pass\n    @property\n    @abstractmethod\n    def retryable_errors(self) -> set[str]:\n        pass",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "baseclasses.base_classes",
        "description": "baseclasses.base_classes",
        "peekOfCode": "logger = logging.getLogger(__name__)\n#Vector Datastore\nclass VectorDatabase(ABC):\n    @abstractmethod\n    def create_index(self, index_name: str, mapping: Dict[str, Any], algorithm: str) -> None:\n        \"\"\"Create a new index with the specified mapping and algorithm.\"\"\"\n        pass\n    @abstractmethod\n    def update_index(self, index_name: str, new_mapping: Dict[str, Any]) -> None:\n        \"\"\"Update an existing index with a new mapping.\"\"\"",
        "detail": "baseclasses.base_classes",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "class Config:\n    \"\"\"Configuration class for AWS and OpenSearch settings.\"\"\"\n    profile_name: Optional[str]\n    aws_region: str\n    bedrock_endpoint_url: Optional[str]\n    opensearch_host: str\n    vector_field: str\n    vector_index_name: str\n    opensearch_serverless: bool\n    execution_table: str",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "config.config",
        "description": "config.config",
        "peekOfCode": "def get_config() -> Config:\n    \"\"\"\n    Get validated configuration.\n    Returns:\n        Config: Validated configuration object\n    Raises:\n        ValueError: If configuration validation fails\n    \"\"\"\n    config = Config.load_config()\n    return config",
        "detail": "config.config",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfig",
        "kind": 6,
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "peekOfCode": "class ExperimentalConfig(BaseModel):\n    execution_id: str\n    experiment_id: str \n    aws_region: str = Field(alias=\"aws_region\")\n    kb_data: str = Field(alias=\"kb_data\")\n    gt_data: str = Field(alias=\"gt_data\")\n    chunking_strategy: str = Field(alias=\"chunking_strategy\")\n    chunk_size: Union[int, List] = Field(alias=\"chunk_size\")\n    chunk_overlap: Union[int, List] = Field(alias=\"chunk_overlap\")\n    hierarchical_parent_chunk_size: int = Field(alias=\"hierarchical_parent_chunk_size\")",
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "NShotPromptGuide",
        "kind": 6,
        "importPath": "config.experimental_config",
        "description": "config.experimental_config",
        "peekOfCode": "class NShotPromptGuide(BaseModel):\n    system_prompt: str\n    examples: Optional[list[dict[str, str]]] = Field(default=None)\n    user_prompt: str",
        "detail": "config.experimental_config",
        "documentation": {}
    },
    {
        "label": "ErrorTypes",
        "kind": 6,
        "importPath": "constants.app_constants",
        "description": "constants.app_constants",
        "peekOfCode": "class ErrorTypes:\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    SERVER_ERROR = \"SERVER_ERROR\"\n    UNAUTHORIZED_ERROR = \"UNAUTHORIZED_ERROR\"\n    NOT_FOUND_ERROR = \"NOT_FOUND_ERROR\"\nclass StatusCodes:\n    SUCCESS = 200\n    CREATED = 201\n    ACCEPTED = 202\n    BAD_REQUEST = 400",
        "detail": "constants.app_constants",
        "documentation": {}
    },
    {
        "label": "StatusCodes",
        "kind": 6,
        "importPath": "constants.app_constants",
        "description": "constants.app_constants",
        "peekOfCode": "class StatusCodes:\n    SUCCESS = 200\n    CREATED = 201\n    ACCEPTED = 202\n    BAD_REQUEST = 400\n    UNAUTHORIZED = 401\n    FORBIDDEN = 403\n    NOT_FOUND = 404\n    INTERNAL_SERVER_ERROR = 500",
        "detail": "constants.app_constants",
        "documentation": {}
    },
    {
        "label": "SageMakerInstanceConstants",
        "kind": 6,
        "importPath": "constants.sagemaker_constants",
        "description": "constants.sagemaker_constants",
        "peekOfCode": "class SageMakerInstanceConstants:\n    INSTANCE_CONFIGS: Final[Dict[str, str]] = {\n        \"BAAI/bge-large-en-v1.5\": \"ml.g5.2xlarge\",\n        \"Qwen/Qwen2.5-32B-Instruct\": \"g6e.12xlarge\",\n        \"Qwen/Qwen2.5-14B-Instruct\": \"g6e.2xlarge\",\n        \"meta-llama/Llama-3.1-8B\": \"ml.g5.2xlarge\",\n        \"meta-llama/Llama-3.1-70B-Instruct\": \"g6e.12xlarge\"\n    }",
        "detail": "constants.sagemaker_constants",
        "documentation": {}
    },
    {
        "label": "ValidationStatus",
        "kind": 6,
        "importPath": "constants.validation_status",
        "description": "constants.validation_status",
        "peekOfCode": "class ValidationStatus(Enum):\n    QUEUED = \"queued\"\n    INPROGRESS = \"inprogress\"\n    FAILED = \"failed\"\n    COMPLETED = \"completed\"",
        "detail": "constants.validation_status",
        "documentation": {}
    },
    {
        "label": "FixedChunker",
        "kind": 6,
        "importPath": "core.chunking.fixed_chunker",
        "description": "core.chunking.fixed_chunker",
        "peekOfCode": "class FixedChunker(BaseChunker):\n    \"\"\"Fixed chunking strategy using LangChains CharacterTextSplitter.\"\"\"\n    def chunk(self, text : str) -> List[str]:\n        if self.chunk_size <= 0:\n            raise ValueError(\"chunk_size must be positive\")\n        if self.chunk_overlap >= self.chunk_size:\n            raise ValueError(\"chunk_overlap must be less than chunk_size\")\n        if not text:\n            raise ValueError(\"Input text cannot be empty or None\")\n        # TODO: Temporary fix, better to move to recursive",
        "detail": "core.chunking.fixed_chunker",
        "documentation": {}
    },
    {
        "label": "HierarchicalChunker",
        "kind": 6,
        "importPath": "core.chunking.hierarchical_chunker",
        "description": "core.chunking.hierarchical_chunker",
        "peekOfCode": "class HierarchicalChunker(BaseHierarchicalChunker):\n    \"\"\"Hierarchical chunking strategy.\"\"\"\n    def chunk(self, text : str) -> List[List[str]]:\n        overlap_tokens = int((self.chunk_overlap / 100) * self.child_chunk_size)\n        if self.parent_chunk_size <= 0:\n            raise ValueError(\"parent chunk size must be positive\")\n        if self.child_chunk_size <= 0:\n            raise ValueError(\"child chunk size must be positive\")\n        if self.child_chunk_size > self.parent_chunk_size:\n            raise ValueError(\"child chunk size must be less than parent chunk size\")",
        "detail": "core.chunking.hierarchical_chunker",
        "documentation": {}
    },
    {
        "label": "BedrockEmbedder",
        "kind": 6,
        "importPath": "core.embedding.bedrock.bedrock_embedder",
        "description": "core.embedding.bedrock.bedrock_embedder",
        "peekOfCode": "class BedrockEmbedder(BaseEmbedder):\n    def __init__(self, model_id: str, region: str, role_arn: str = None) -> None:\n        super().__init__(model_id)\n        self.client = boto3.client(\"bedrock-runtime\", region_name=region)\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        raise NotImplementedError(\"Subclasses must implement `prepare_payload`\")\n    @BedRockRetryHander()\n    def embed(self, text: str, dimensions: int = 256, normalize: bool = True) -> Tuple[Dict[Any, Any], List[float]]:\n        try:\n            payload = self.prepare_payload(text, dimensions, normalize)",
        "detail": "core.embedding.bedrock.bedrock_embedder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.bedrock.bedrock_embedder",
        "description": "core.embedding.bedrock.bedrock_embedder",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n# Bedrock Base Embedder\nclass BedrockEmbedder(BaseEmbedder):\n    def __init__(self, model_id: str, region: str, role_arn: str = None) -> None:\n        super().__init__(model_id)\n        self.client = boto3.client(\"bedrock-runtime\", region_name=region)\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        raise NotImplementedError(\"Subclasses must implement `prepare_payload`\")\n    @BedRockRetryHander()",
        "detail": "core.embedding.bedrock.bedrock_embedder",
        "documentation": {}
    },
    {
        "label": "CohereEmbedder",
        "kind": 6,
        "importPath": "core.embedding.bedrock.cohere_embedder",
        "description": "core.embedding.bedrock.cohere_embedder",
        "peekOfCode": "class CohereEmbedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"texts\": [text], \"input_type\": \"search_document\"}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embeddings\"][0]\nEmbedderFactory.register_embedder(\"bedrock\", \"cohere.embed-english-v3\", CohereEmbedder)\nEmbedderFactory.register_embedder(\"bedrock\", \"cohere.embed-multilingual-v3\", CohereEmbedder)",
        "detail": "core.embedding.bedrock.cohere_embedder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.bedrock.cohere_embedder",
        "description": "core.embedding.bedrock.cohere_embedder",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass CohereEmbedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"texts\": [text], \"input_type\": \"search_document\"}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embeddings\"][0]\nEmbedderFactory.register_embedder(\"bedrock\", \"cohere.embed-english-v3\", CohereEmbedder)\nEmbedderFactory.register_embedder(\"bedrock\", \"cohere.embed-multilingual-v3\", CohereEmbedder)",
        "detail": "core.embedding.bedrock.cohere_embedder",
        "documentation": {}
    },
    {
        "label": "TitanV1Embedder",
        "kind": 6,
        "importPath": "core.embedding.bedrock.titanv1_embedder",
        "description": "core.embedding.bedrock.titanv1_embedder",
        "peekOfCode": "class TitanV1Embedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"inputText\": text, \"embeddingConfig\" : {\"outputEmbeddingLength\" : dimensions}}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embedding\"]\nEmbedderFactory.register_embedder(\"bedrock\", \"amazon.titan-embed-image-v1\", TitanV1Embedder)",
        "detail": "core.embedding.bedrock.titanv1_embedder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.bedrock.titanv1_embedder",
        "description": "core.embedding.bedrock.titanv1_embedder",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass TitanV1Embedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"inputText\": text, \"embeddingConfig\" : {\"outputEmbeddingLength\" : dimensions}}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embedding\"]\nEmbedderFactory.register_embedder(\"bedrock\", \"amazon.titan-embed-image-v1\", TitanV1Embedder)",
        "detail": "core.embedding.bedrock.titanv1_embedder",
        "documentation": {}
    },
    {
        "label": "TitanV2Embedder",
        "kind": 6,
        "importPath": "core.embedding.bedrock.titanv2_embedder",
        "description": "core.embedding.bedrock.titanv2_embedder",
        "peekOfCode": "class TitanV2Embedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"inputText\": text, \"dimensions\": dimensions, \"normalize\": normalize}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embedding\"]\nEmbedderFactory.register_embedder(\"bedrock\", \"amazon.titan-embed-text-v2:0\", TitanV2Embedder)",
        "detail": "core.embedding.bedrock.titanv2_embedder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.bedrock.titanv2_embedder",
        "description": "core.embedding.bedrock.titanv2_embedder",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass TitanV2Embedder(BedrockEmbedder):\n    def prepare_payload(self, text: str, dimensions: int, normalize: bool) -> Dict:\n        return {\"inputText\": text, \"dimensions\": dimensions, \"normalize\": normalize}\n    def extract_embedding(self, response: Dict) -> List[float]:\n        return response[\"embedding\"]\nEmbedderFactory.register_embedder(\"bedrock\", \"amazon.titan-embed-text-v2:0\", TitanV2Embedder)",
        "detail": "core.embedding.bedrock.titanv2_embedder",
        "documentation": {}
    },
    {
        "label": "SageMakerEmbedder",
        "kind": 6,
        "importPath": "core.embedding.sagemaker.sagemaker_embedder",
        "description": "core.embedding.sagemaker.sagemaker_embedder",
        "peekOfCode": "class SageMakerEmbedder(BaseEmbedder):\n    def __init__(self, model_id: str, region: str, role_arn: str) -> None:\n        \"\"\"\n        Initializes the SageMakerEmbedder with the given model ID, region, and role ARN.\n        Sets up necessary SageMaker runtime clients, session, and endpoint predictor.\n        Args:\n            model_id (str): The unique identifier for the model.\n            region (str): The AWS region where the SageMaker services are hosted.\n            role_arn (str): The ARN of the IAM role. Currently not used but included for future extensions.\n        \"\"\"",
        "detail": "core.embedding.sagemaker.sagemaker_embedder",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.sagemaker.sagemaker_embedder",
        "description": "core.embedding.sagemaker.sagemaker_embedder",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n# Model configurations\nEMBEDDING_MODELS = {\n    \"huggingface-sentencesimilarity-bge-large-en-v1-5\": {\n        \"model_name\": \"bge-large\",\n        \"model_source\": \"jumpstart\",\n        \"dimension\": 1024,\n        \"instance_type\": \"ml.g5.2xlarge\",\n        \"input_key\": \"text_inputs\"",
        "detail": "core.embedding.sagemaker.sagemaker_embedder",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_MODELS",
        "kind": 5,
        "importPath": "core.embedding.sagemaker.sagemaker_embedder",
        "description": "core.embedding.sagemaker.sagemaker_embedder",
        "peekOfCode": "EMBEDDING_MODELS = {\n    \"huggingface-sentencesimilarity-bge-large-en-v1-5\": {\n        \"model_name\": \"bge-large\",\n        \"model_source\": \"jumpstart\",\n        \"dimension\": 1024,\n        \"instance_type\": \"ml.g5.2xlarge\",\n        \"input_key\": \"text_inputs\"\n    },\n    \"huggingface-sentencesimilarity-bge-m3\": {\n        \"model_name\": \"bge-m3\",",
        "detail": "core.embedding.sagemaker.sagemaker_embedder",
        "documentation": {}
    },
    {
        "label": "EmbedderFactory",
        "kind": 6,
        "importPath": "core.embedding.embedding_factory",
        "description": "core.embedding.embedding_factory",
        "peekOfCode": "class EmbedderFactory:\n    \"\"\"Factory to create embedders based on model ID and service type.\"\"\"\n    _registry: Dict[str, Type[BaseEmbedder]] = {}\n    @classmethod\n    def register_embedder(cls, service_type: str, model_id: str, embedder_cls: Type[BaseEmbedder]):\n        key = f\"{service_type}:{model_id}\"\n        cls._registry[key] = embedder_cls\n    @classmethod\n    def create_embedder(cls, experimentalConfig : ExperimentalConfig) -> BaseEmbedder:\n        service_type = experimentalConfig.embedding_service",
        "detail": "core.embedding.embedding_factory",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.embedding.embedding_factory",
        "description": "core.embedding.embedding_factory",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass EmbedderFactory:\n    \"\"\"Factory to create embedders based on model ID and service type.\"\"\"\n    _registry: Dict[str, Type[BaseEmbedder]] = {}\n    @classmethod\n    def register_embedder(cls, service_type: str, model_id: str, embedder_cls: Type[BaseEmbedder]):\n        key = f\"{service_type}:{model_id}\"\n        cls._registry[key] = embedder_cls\n    @classmethod",
        "detail": "core.embedding.embedding_factory",
        "documentation": {}
    },
    {
        "label": "RagasEvaluator",
        "kind": 6,
        "importPath": "core.eval.ragas.ragas_eval",
        "description": "core.eval.ragas.ragas_eval",
        "peekOfCode": "class RagasEvaluator(BaseEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialize_dynamodb()\n    def _initialize_dynamodb(self):\n        \"\"\"Initialize DynamoDB connections\"\"\"\n        self.metrics_db = DynamoDBOperations(\n            region=self.config.aws_region,\n            table_name=self.config.experiment_question_metrics_table\n        )",
        "detail": "core.eval.ragas.ragas_eval",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.eval.ragas.ragas_eval",
        "description": "core.eval.ragas.ragas_eval",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nclass RagasEvaluator(BaseEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialize_dynamodb()\n    def _initialize_dynamodb(self):\n        \"\"\"Initialize DynamoDB connections\"\"\"\n        self.metrics_db = DynamoDBOperations(\n            region=self.config.aws_region,",
        "detail": "core.eval.ragas.ragas_eval",
        "documentation": {}
    },
    {
        "label": "RagasLLMEvaluator",
        "kind": 6,
        "importPath": "core.eval.ragas.ragas_llm_eval",
        "description": "core.eval.ragas.ragas_llm_eval",
        "peekOfCode": "class RagasLLMEvaluator(RagasEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialze_llm()\n        self._initialize_scorers()\n    def _initialze_llm(self):\n        self.evaluator_llm = LangchainLLMWrapper(ChatBedrockConverse(\n            region_name=self.experimental_config.aws_region,\n            base_url=f\"https://bedrock-runtime.{self.experimental_config.aws_region}.amazonaws.com\",\n            model=self.experimental_config.eval_retrieval_model,",
        "detail": "core.eval.ragas.ragas_llm_eval",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.eval.ragas.ragas_llm_eval",
        "description": "core.eval.ragas.ragas_llm_eval",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nclass RagasLLMEvaluator(RagasEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialze_llm()\n        self._initialize_scorers()\n    def _initialze_llm(self):\n        self.evaluator_llm = LangchainLLMWrapper(ChatBedrockConverse(\n            region_name=self.experimental_config.aws_region,",
        "detail": "core.eval.ragas.ragas_llm_eval",
        "documentation": {}
    },
    {
        "label": "RagasNonLLMEvaluator",
        "kind": 6,
        "importPath": "core.eval.ragas.ragas_non_llm_eval",
        "description": "core.eval.ragas.ragas_non_llm_eval",
        "peekOfCode": "class RagasNonLLMEvaluator(RagasEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialize_scorers()\n    def _initialize_scorers(self):\n        \"\"\"Initialize all metric scorers\"\"\"\n        self.str_similar_scorer = NonLLMStringSimilarity()\n        self.context_recall = NonLLMContextRecall()\n        self.context_precision = NonLLMContextPrecisionWithReference()\n        self.rouge_score = RougeScore()",
        "detail": "core.eval.ragas.ragas_non_llm_eval",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.eval.ragas.ragas_non_llm_eval",
        "description": "core.eval.ragas.ragas_non_llm_eval",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nclass RagasNonLLMEvaluator(RagasEvaluator):\n    def __init__(self, config, experimental_config):\n        super().__init__(config, experimental_config)\n        self._initialize_scorers()\n    def _initialize_scorers(self):\n        \"\"\"Initialize all metric scorers\"\"\"\n        self.str_similar_scorer = NonLLMStringSimilarity()\n        self.context_recall = NonLLMContextRecall()",
        "detail": "core.eval.ragas.ragas_non_llm_eval",
        "documentation": {}
    },
    {
        "label": "EvaluatorServiceError",
        "kind": 6,
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "peekOfCode": "class EvaluatorServiceError(Exception):\n    \"\"\"Custom exception for inference service related errors\"\"\"\n    pass\nclass EvalFactory:\n    _registry: Dict[str, Type[BaseEvaluator]] = {}\n    @classmethod\n    def register_evaluator(cls, service_type: str, eval_type: str, evaluator_cls: Type[BaseEvaluator]):\n        key = f\"{service_type}:{eval_type}\"\n        cls._registry[key] = evaluator_cls\n    @classmethod",
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "EvalFactory",
        "kind": 6,
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "peekOfCode": "class EvalFactory:\n    _registry: Dict[str, Type[BaseEvaluator]] = {}\n    @classmethod\n    def register_evaluator(cls, service_type: str, eval_type: str, evaluator_cls: Type[BaseEvaluator]):\n        key = f\"{service_type}:{eval_type}\"\n        cls._registry[key] = evaluator_cls\n    @classmethod\n    def create_evaluator(cls, experimentalConfig: ExperimentalConfig) -> BaseEvaluator:\n        config = Config.load_config()\n        eval_service_type = experimentalConfig.eval_service",
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.eval.eval_factory",
        "description": "core.eval.eval_factory",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass EvaluatorServiceError(Exception):\n    \"\"\"Custom exception for inference service related errors\"\"\"\n    pass\nclass EvalFactory:\n    _registry: Dict[str, Type[BaseEvaluator]] = {}\n    @classmethod\n    def register_evaluator(cls, service_type: str, eval_type: str, evaluator_cls: Type[BaseEvaluator]):\n        key = f\"{service_type}:{eval_type}\"",
        "detail": "core.eval.eval_factory",
        "documentation": {}
    },
    {
        "label": "BedrockGuardrails",
        "kind": 6,
        "importPath": "core.guardrails.bedrock_guardrails",
        "description": "core.guardrails.bedrock_guardrails",
        "peekOfCode": "class BedrockGuardrails:\n    def __init__(self, region: str = 'us-east-1'):\n        self.bedrock_client = boto3.client('bedrock', region_name = region)\n        self.runtime_client = boto3.client('bedrock-runtime', region_name = region)\n    def create_guardrail(\n        self,\n        guardrail_config: dict\n    ) -> Dict:\n        \"\"\"\n        Create a comprehensive guardrail using Amazon Bedrock",
        "detail": "core.guardrails.bedrock_guardrails",
        "documentation": {}
    },
    {
        "label": "get_comprehensive_guardrail_config",
        "kind": 2,
        "importPath": "core.guardrails.bedrock_guardrails",
        "description": "core.guardrails.bedrock_guardrails",
        "peekOfCode": "def get_comprehensive_guardrail_config():\n    \"\"\"\n    Complete guardrail configuration with all policy types\n    \"\"\"\n    # Content Policy Configuration\n    content_policy = {\n        'filtersConfig': [{\n            'type': 'HATE', #'SEXUAL'|'VIOLENCE'|'HATE'|'INSULTS'|'MISCONDUCT'|'PROMPT_ATTACK'\n            'inputStrength': 'LOW', #'NONE'|'LOW'|'MEDIUM'|'HIGH'\n            'outputStrength': 'LOW', #'NONE'|'LOW'|'MEDIUM'|'HIGH',",
        "detail": "core.guardrails.bedrock_guardrails",
        "documentation": {}
    },
    {
        "label": "create_domain_specific_guardrail",
        "kind": 2,
        "importPath": "core.guardrails.bedrock_guardrails",
        "description": "core.guardrails.bedrock_guardrails",
        "peekOfCode": "def create_domain_specific_guardrail():\n    \"\"\"\n    Create a domain-specific guardrail with all policy types\n    \"\"\"\n    guardrails = BedrockGuardrails()\n    config = get_comprehensive_guardrail_config()\n    response = guardrails.create_guardrail(\n        name='ComprehensiveGuardrail',\n        description='Complete guardrail with all policy configurations',\n        **config",
        "detail": "core.guardrails.bedrock_guardrails",
        "documentation": {}
    },
    {
        "label": "BedrockInferencer",
        "kind": 6,
        "importPath": "core.inference.bedrock.bedrock_inferencer",
        "description": "core.inference.bedrock.bedrock_inferencer",
        "peekOfCode": "class BedrockInferencer(BaseInferencer):\n    \"\"\"Base class for all Bedrock models since they share the same invocation pattern\"\"\"\n    # This part was added as part of the SageMaker implementation changes. \n    # Due to updates in the base class implementation, the invocation point was changed from \n    # '_initialize_client' to '__init__'.\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str = 'us-east-1', role_arn: str = None):\n        super().__init__(model_id, experiment_config, region, role_arn)\n        self._initialize_client() \n    def _initialize_client(self) -> None:\n        self.client = boto3.client(",
        "detail": "core.inference.bedrock.bedrock_inferencer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.inference.bedrock.bedrock_inferencer",
        "description": "core.inference.bedrock.bedrock_inferencer",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n# Class for handling inference using Amazon Bedrock \nclass BedrockInferencer(BaseInferencer):\n    \"\"\"Base class for all Bedrock models since they share the same invocation pattern\"\"\"\n    # This part was added as part of the SageMaker implementation changes. \n    # Due to updates in the base class implementation, the invocation point was changed from \n    # '_initialize_client' to '__init__'.\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str = 'us-east-1', role_arn: str = None):\n        super().__init__(model_id, experiment_config, region, role_arn)",
        "detail": "core.inference.bedrock.bedrock_inferencer",
        "documentation": {}
    },
    {
        "label": "model_list",
        "kind": 5,
        "importPath": "core.inference.bedrock.bedrock_inferencer",
        "description": "core.inference.bedrock.bedrock_inferencer",
        "peekOfCode": "model_list = [\"mistral.mistral-7b-instruct-v0:2\",\n              \"mistral.mistral-large-2402-v1:0\",\n              \"us.meta.llama3-2-90b-instruct-v1:0\",\n              \"us.meta.llama3-2-11b-instruct-v1:0\",\n              \"us.meta.llama3-2-3b-instruct-v1:0\",\n              \"us.meta.llama3-2-1b-instruct-v1:0\",\n              \"cohere.command-r-v1:0\",\n              \"cohere.command-r-plus-v1:0\",\n              \"anthropic.claude-3-5-sonnet-20240620-v1:0\",\n              \"us.anthropic.claude-3-5-sonnet-20241022-v2:0\",",
        "detail": "core.inference.bedrock.bedrock_inferencer",
        "documentation": {}
    },
    {
        "label": "LlamaInferencer",
        "kind": 6,
        "importPath": "core.inference.sagemaker.llama_inferencer",
        "description": "core.inference.sagemaker.llama_inferencer",
        "peekOfCode": "class LlamaInferencer(SageMakerInferencer):\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str, role_arn: str):\n        super().__init__(model_id, experiment_config, region, role_arn)\n    def _prepare_conversation(self, message: str, role: str):\n        # Format message and role into a conversation\n        if not message or not role:\n            logger.error(f\"Error in parsing message or role\")\n        conversation = {\n                \"role\": role, \n                \"content\": message",
        "detail": "core.inference.sagemaker.llama_inferencer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.inference.sagemaker.llama_inferencer",
        "description": "core.inference.sagemaker.llama_inferencer",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass LlamaInferencer(SageMakerInferencer):\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str, role_arn: str):\n        super().__init__(model_id, experiment_config, region, role_arn)\n    def _prepare_conversation(self, message: str, role: str):\n        # Format message and role into a conversation\n        if not message or not role:\n            logger.error(f\"Error in parsing message or role\")\n        conversation = {",
        "detail": "core.inference.sagemaker.llama_inferencer",
        "documentation": {}
    },
    {
        "label": "SageMakerInferencer",
        "kind": 6,
        "importPath": "core.inference.sagemaker.sagemaker_inferencer",
        "description": "core.inference.sagemaker.sagemaker_inferencer",
        "peekOfCode": "class SageMakerInferencer(BaseInferencer):\n    def __init__(self, model_id: str, experiment_config: ExperimentalConfig, region: str, role_arn: str):\n        \"\"\"\n        Initializes the SageMakerInferencer with the given model ID, region, and role ARN.\n        Sets up necessary SageMaker runtime clients, session, and endpoint predictor.\n        Args:\n            model_id (str): The unique identifier for the model.\n            region (str): The AWS region where the SageMaker services are hosted.\n            role_arn (str): The ARN of the IAM role. Currently not used but included for future extensions.\n        \"\"\"",
        "detail": "core.inference.sagemaker.sagemaker_inferencer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.inference.sagemaker.sagemaker_inferencer",
        "description": "core.inference.sagemaker.sagemaker_inferencer",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n# Model configurations\nINFERENCER_MODELS = {\n    \"meta-textgeneration-llama-3-1-8b-instruct\": {\n        \"model_source\": \"jumpstart\",\n        \"instance_type\": \"ml.g5.2xlarge\"\n    },\n    \"huggingface-llm-falcon-7b-instruct-bf16\": {\n        \"model_source\": \"jumpstart\",",
        "detail": "core.inference.sagemaker.sagemaker_inferencer",
        "documentation": {}
    },
    {
        "label": "INFERENCER_MODELS",
        "kind": 5,
        "importPath": "core.inference.sagemaker.sagemaker_inferencer",
        "description": "core.inference.sagemaker.sagemaker_inferencer",
        "peekOfCode": "INFERENCER_MODELS = {\n    \"meta-textgeneration-llama-3-1-8b-instruct\": {\n        \"model_source\": \"jumpstart\",\n        \"instance_type\": \"ml.g5.2xlarge\"\n    },\n    \"huggingface-llm-falcon-7b-instruct-bf16\": {\n        \"model_source\": \"jumpstart\",\n        \"instance_type\": \"ml.g5.2xlarge\"\n    },\n    \"meta-textgeneration-llama-3-3-70b-instruct\": {",
        "detail": "core.inference.sagemaker.sagemaker_inferencer",
        "documentation": {}
    },
    {
        "label": "InferenceServiceError",
        "kind": 6,
        "importPath": "core.inference.inference_factory",
        "description": "core.inference.inference_factory",
        "peekOfCode": "class InferenceServiceError(Exception):\n    \"\"\"Custom exception for inference service related errors\"\"\"\n    pass\nclass InferencerFactory:\n    \"\"\"Factory to create embedders based on model ID and service type.\"\"\"\n    _registry: Dict[str, Type[BaseInferencer]] = {}\n    @classmethod\n    def register_inferencer(cls, service_type: str, model_id: str, embedder_cls: Type[BaseInferencer]):\n        key = f\"{service_type}:{model_id}\"\n        cls._registry[key] = embedder_cls",
        "detail": "core.inference.inference_factory",
        "documentation": {}
    },
    {
        "label": "InferencerFactory",
        "kind": 6,
        "importPath": "core.inference.inference_factory",
        "description": "core.inference.inference_factory",
        "peekOfCode": "class InferencerFactory:\n    \"\"\"Factory to create embedders based on model ID and service type.\"\"\"\n    _registry: Dict[str, Type[BaseInferencer]] = {}\n    @classmethod\n    def register_inferencer(cls, service_type: str, model_id: str, embedder_cls: Type[BaseInferencer]):\n        key = f\"{service_type}:{model_id}\"\n        cls._registry[key] = embedder_cls\n    @classmethod\n    def create_inferencer(cls, experimentalConfig : ExperimentalConfig) -> BaseInferencer:\n        service_type = experimentalConfig.retrieval_service",
        "detail": "core.inference.inference_factory",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.inference.inference_factory",
        "description": "core.inference.inference_factory",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass InferenceServiceError(Exception):\n    \"\"\"Custom exception for inference service related errors\"\"\"\n    pass\nclass InferencerFactory:\n    \"\"\"Factory to create embedders based on model ID and service type.\"\"\"\n    _registry: Dict[str, Type[BaseInferencer]] = {}\n    @classmethod\n    def register_inferencer(cls, service_type: str, model_id: str, embedder_cls: Type[BaseInferencer]):",
        "detail": "core.inference.inference_factory",
        "documentation": {}
    },
    {
        "label": "ChunkingProcessor",
        "kind": 6,
        "importPath": "core.processors.chunking_processor",
        "description": "core.processors.chunking_processor",
        "peekOfCode": "class ChunkingProcessor:\n    \"\"\"Processor for managing text chunking.\"\"\"\n    CHUNKER_STRATEGIES: Dict[str, Union[Type[BaseChunker], Type[BaseHierarchicalChunker]]] = {\n        \"Fixed\": FixedChunker,\n        \"Hierarchical\": HierarchicalChunker\n    }\n    def __init__(self,  experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.chunker = self._initialize_chunker()\n    def _initialize_chunker(self) -> Union[BaseChunker, BaseHierarchicalChunker]:",
        "detail": "core.processors.chunking_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.processors.chunking_processor",
        "description": "core.processors.chunking_processor",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass ChunkingProcessor:\n    \"\"\"Processor for managing text chunking.\"\"\"\n    CHUNKER_STRATEGIES: Dict[str, Union[Type[BaseChunker], Type[BaseHierarchicalChunker]]] = {\n        \"Fixed\": FixedChunker,\n        \"Hierarchical\": HierarchicalChunker\n    }\n    def __init__(self,  experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig",
        "detail": "core.processors.chunking_processor",
        "documentation": {}
    },
    {
        "label": "EmbedProcessor",
        "kind": 6,
        "importPath": "core.processors.embed_processor",
        "description": "core.processors.embed_processor",
        "peekOfCode": "class EmbedProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.embedder = EmbedderFactory.create_embedder(experimentalConfig)\n    def embed(self, chunks: List[str]) -> List[Tuple[List[float], str, Dict[Any, Any]]]:\n        \"\"\"Embed each chunk one by one.\"\"\"\n        embeddings = []\n        try:\n            dimensions = self.experimentalConfig.vector_dimension ",
        "detail": "core.processors.embed_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.processors.embed_processor",
        "description": "core.processors.embed_processor",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass EmbedProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.embedder = EmbedderFactory.create_embedder(experimentalConfig)\n    def embed(self, chunks: List[str]) -> List[Tuple[List[float], str, Dict[Any, Any]]]:\n        \"\"\"Embed each chunk one by one.\"\"\"\n        embeddings = []",
        "detail": "core.processors.embed_processor",
        "documentation": {}
    },
    {
        "label": "EvalProcessor",
        "kind": 6,
        "importPath": "core.processors.eval_processor",
        "description": "core.processors.eval_processor",
        "peekOfCode": "class EvalProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.evaluator = EvalFactory.create_evaluator(experimentalConfig)\n    def evaluate(self) -> None:\n        try:\n            self.evaluator.evaluate(experiment_id=self.experimentalConfig.experiment_id)\n        except Exception as e:\n            logger.error(f\"Error generating eval: {str(e)}\")",
        "detail": "core.processors.eval_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.processors.eval_processor",
        "description": "core.processors.eval_processor",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass EvalProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.evaluator = EvalFactory.create_evaluator(experimentalConfig)\n    def evaluate(self) -> None:\n        try:\n            self.evaluator.evaluate(experiment_id=self.experimentalConfig.experiment_id)",
        "detail": "core.processors.eval_processor",
        "documentation": {}
    },
    {
        "label": "InferenceProcessor",
        "kind": 6,
        "importPath": "core.processors.inference_processor",
        "description": "core.processors.inference_processor",
        "peekOfCode": "class InferenceProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.inferencer = InferencerFactory.create_inferencer(experimentalConfig)\n    def generate_text(self, user_query: str, default_prompt: str, context: List[Dict] = None, **kwargs) -> Tuple[Dict[Any,Any], str]:\n        try:\n            metadata, answer = self.inferencer.generate_text(\n                user_query=user_query,\n                context = context,",
        "detail": "core.processors.inference_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.processors.inference_processor",
        "description": "core.processors.inference_processor",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass InferenceProcessor:\n    \"\"\"Processor for embedding text chunks.\"\"\"\n    def __init__(self, experimentalConfig : ExperimentalConfig) -> None:\n        self.experimentalConfig = experimentalConfig\n        self.inferencer = InferencerFactory.create_inferencer(experimentalConfig)\n    def generate_text(self, user_query: str, default_prompt: str, context: List[Dict] = None, **kwargs) -> Tuple[Dict[Any,Any], str]:\n        try:\n            metadata, answer = self.inferencer.generate_text(",
        "detail": "core.processors.inference_processor",
        "documentation": {}
    },
    {
        "label": "DocumentReranker",
        "kind": 6,
        "importPath": "core.rerank.rerank",
        "description": "core.rerank.rerank",
        "peekOfCode": "class DocumentReranker:\n    def __init__(self, region, rerank_model_id):\n        \"\"\"\n        Initialize the DocumentReranker with the AWS region, model ID, and Bedrock agent runtime.\n        Args:\n            region (str): The AWS region to use.\n            model_id (str): The model ID to use for reranking.\n            bedrock_agent_runtime (object): The Bedrock agent runtime instance to interact with the API.\n        \"\"\"\n        self.region = region",
        "detail": "core.rerank.rerank",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.rerank.rerank",
        "description": "core.rerank.rerank",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.ERROR)\nclass DocumentReranker:\n    def __init__(self, region, rerank_model_id):\n        \"\"\"\n        Initialize the DocumentReranker with the AWS region, model ID, and Bedrock agent runtime.\n        Args:\n            region (str): The AWS region to use.\n            model_id (str): The model ID to use for reranking.\n            bedrock_agent_runtime (object): The Bedrock agent runtime instance to interact with the API.",
        "detail": "core.rerank.rerank",
        "documentation": {}
    },
    {
        "label": "ExperimentalConfigService",
        "kind": 6,
        "importPath": "core.service.experimental_config_service",
        "description": "core.service.experimental_config_service",
        "peekOfCode": "class ExperimentalConfigService:\n    \"\"\"Service class to manage experimental configurations.\"\"\"\n    def __init__(self, config: Config):\n        self.aws_region = config.aws_region\n        self.experiment_db = DynamoDBOperations(\n            region=self.aws_region,\n            table_name=config.experiment_table\n        )\n    def _validate_n_shot_prompts(self, experiment_id: str, n_shot_prompt_guide: NShotPromptGuide, \n                               required_examples: int) -> None:",
        "detail": "core.service.experimental_config_service",
        "documentation": {}
    },
    {
        "label": "DynamoDBOperations",
        "kind": 6,
        "importPath": "core.dynamodb",
        "description": "core.dynamodb",
        "peekOfCode": "class DynamoDBOperations:\n    \"\"\"Class to handle DynamoDB operations.\"\"\"\n    def __init__(self, table_name: str, region: str = 'us-east-1'):\n        \"\"\"\n        Initialize DynamoDB operations.\n        Args:\n            table_name (str): DynamoDB table name\n            region (str): AWS region\n        \"\"\"\n        self.table_name = table_name",
        "detail": "core.dynamodb",
        "documentation": {}
    },
    {
        "label": "KnowledgeBaseVectorDatabase",
        "kind": 6,
        "importPath": "core.knowledgebase_vectorstore",
        "description": "core.knowledgebase_vectorstore",
        "peekOfCode": "class KnowledgeBaseVectorDatabase(VectorDatabase):\n    def __init__(self, region: str = 'us-east-1'):\n        self.client = boto3.client(\"bedrock-agent-runtime\", region_name=region)\n    def create_index(self, index_name: str, mapping: Dict[str, Any], algorithm: str) -> None:\n        raise NotImplementedError(\"This method is not implemented in this minimal version.\")\n    def update_index(self, index_name: str, new_mapping: Dict[str, Any]) -> None:\n        raise NotImplementedError(\"This method is not implemented in this minimal version.\")\n    def delete_index(self, index_name: str) -> None:\n        raise NotImplementedError(\"This method is not implemented in this minimal version.\")\n    def insert_document(self, index_name: str, document: Dict[str, Any]) -> None:",
        "detail": "core.knowledgebase_vectorstore",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.knowledgebase_vectorstore",
        "description": "core.knowledgebase_vectorstore",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass KnowledgeBaseVectorDatabase(VectorDatabase):\n    def __init__(self, region: str = 'us-east-1'):\n        self.client = boto3.client(\"bedrock-agent-runtime\", region_name=region)\n    def create_index(self, index_name: str, mapping: Dict[str, Any], algorithm: str) -> None:\n        raise NotImplementedError(\"This method is not implemented in this minimal version.\")\n    def update_index(self, index_name: str, new_mapping: Dict[str, Any]) -> None:\n        raise NotImplementedError(\"This method is not implemented in this minimal version.\")\n    def delete_index(self, index_name: str) -> None:",
        "detail": "core.knowledgebase_vectorstore",
        "documentation": {}
    },
    {
        "label": "OpenSearchVectorDatabase",
        "kind": 6,
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "peekOfCode": "class OpenSearchVectorDatabase(VectorDatabase):\n    def __init__(self, host: str, use_ssl: bool = True, port: int = 443, is_serverless : bool = True, region: str = 'us-east-1', username: str = None, password: str = None):\n        if is_serverless:\n            try:\n                # Get credentials from the Lambda role\n                credentials = boto3.Session().get_credentials()\n                # Create AWS V4 Signer Auth for OpenSearch Serverless\n                auth = AWSV4SignerAuth(credentials, region, 'aoss')\n                # Initialize OpenSearch client for serverless\n                self.client = OpenSearch(",
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "core.opensearch_vectorstore",
        "description": "core.opensearch_vectorstore",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass OpenSearchVectorDatabase(VectorDatabase):\n    def __init__(self, host: str, use_ssl: bool = True, port: int = 443, is_serverless : bool = True, region: str = 'us-east-1', username: str = None, password: str = None):\n        if is_serverless:\n            try:\n                # Get credentials from the Lambda role\n                credentials = boto3.Session().get_credentials()\n                # Create AWS V4 Signer Auth for OpenSearch Serverless\n                auth = AWSV4SignerAuth(credentials, region, 'aoss')",
        "detail": "core.opensearch_vectorstore",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "evaluation.eval",
        "description": "evaluation.eval",
        "peekOfCode": "def evaluate(experiment_config: ExperimentalConfig):\n    try:\n        EvalProcessor(experiment_config).evaluate()\n    except Exception as e:\n        logger.error(f\"Error during evaluation: {e}\")\n        raise",
        "detail": "evaluation.eval",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "evaluation.eval",
        "description": "evaluation.eval",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef evaluate(experiment_config: ExperimentalConfig):\n    try:\n        EvalProcessor(experiment_config).evaluate()\n    except Exception as e:\n        logger.error(f\"Error during evaluation: {e}\")\n        raise",
        "detail": "evaluation.eval",
        "documentation": {}
    },
    {
        "label": "EvaluationProcessor",
        "kind": 6,
        "importPath": "handlers.fargate_eval_handler",
        "description": "handlers.fargate_eval_handler",
        "peekOfCode": "class EvaluationProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            # Load base configuration\n            config = Config.load_config()\n            exp_config = ExperimentalConfigService(config).create_experimental_config(exp_config_data)\n            logger.info(\"Into evaluate processor. Processing event: %s\", json.dumps(exp_config_data))\n            evaluate(experiment_config=exp_config)",
        "detail": "handlers.fargate_eval_handler",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "handlers.fargate_eval_handler",
        "description": "handlers.fargate_eval_handler",
        "peekOfCode": "def main():\n    try:\n        fargate_processor = EvaluationProcessor()\n        fargate_processor.process()\n    except Exception as e:\n        logger.error(f\"Error processing event: {str(e)}\")\n        raise\nif __name__ == \"__main__\":\n    main()",
        "detail": "handlers.fargate_eval_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "handlers.fargate_eval_handler",
        "description": "handlers.fargate_eval_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nclass EvaluationProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            # Load base configuration\n            config = Config.load_config()\n            exp_config = ExperimentalConfigService(config).create_experimental_config(exp_config_data)",
        "detail": "handlers.fargate_eval_handler",
        "documentation": {}
    },
    {
        "label": "IndexingProcessor",
        "kind": 6,
        "importPath": "handlers.fargate_indexing_handler",
        "description": "handlers.fargate_indexing_handler",
        "peekOfCode": "class IndexingProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            logger.info(\"Into indexing processor. Processing event: %s\", json.dumps(exp_config_data))\n             # Load base configuration\n            config = Config.load_config()\n            exp_config = ExperimentalConfigService(config).create_experimental_config(exp_config_data)\n            logger.info(\"Into indexing processor. Processing event: %s\", json.dumps(exp_config_data))",
        "detail": "handlers.fargate_indexing_handler",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "handlers.fargate_indexing_handler",
        "description": "handlers.fargate_indexing_handler",
        "peekOfCode": "def main():\n    try:\n        fargate_processor = IndexingProcessor()\n        fargate_processor.process()\n    except Exception as e:\n        logger.error(f\"Error processing event: {str(e)}\")\n        raise\nif __name__ == \"__main__\":\n    main()",
        "detail": "handlers.fargate_indexing_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "handlers.fargate_indexing_handler",
        "description": "handlers.fargate_indexing_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nclass IndexingProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            logger.info(\"Into indexing processor. Processing event: %s\", json.dumps(exp_config_data))\n             # Load base configuration\n            config = Config.load_config()",
        "detail": "handlers.fargate_indexing_handler",
        "documentation": {}
    },
    {
        "label": "RetrieverProcessor",
        "kind": 6,
        "importPath": "handlers.fargate_retriever_handler",
        "description": "handlers.fargate_retriever_handler",
        "peekOfCode": "class RetrieverProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            # Load base configuration\n            config = Config.load_config()\n            exp_config = ExperimentalConfigService(config).create_experimental_config(exp_config_data)\n            logger.info(\"Into retriever processor. Processing event: %s\", json.dumps(exp_config_data))\n            # Execute retrieve method",
        "detail": "handlers.fargate_retriever_handler",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "handlers.fargate_retriever_handler",
        "description": "handlers.fargate_retriever_handler",
        "peekOfCode": "def main():\n    try:\n        fargate_processor = RetrieverProcessor()\n        fargate_processor.process()\n    except Exception as e:\n        logger.error(f\"Error processing event: {str(e)}\")\n        raise\nif __name__ == \"__main__\":\n    main()",
        "detail": "handlers.fargate_retriever_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "handlers.fargate_retriever_handler",
        "description": "handlers.fargate_retriever_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nclass RetrieverProcessor(FargateTaskProcessor):\n    def process(self):\n        try:\n            logger.info(\"Input data: %s\", self.input_data)\n            exp_config_data = self.input_data\n            # Load base configuration\n            config = Config.load_config()\n            exp_config = ExperimentalConfigService(config).create_experimental_config(exp_config_data)",
        "detail": "handlers.fargate_retriever_handler",
        "documentation": {}
    },
    {
        "label": "FargateTaskProcessor",
        "kind": 6,
        "importPath": "handlers.task_processor",
        "description": "handlers.task_processor",
        "peekOfCode": "class FargateTaskProcessor():\n    def __init__(self):\n        self.sfn_client = boto3.client('stepfunctions')\n        self.task_token = os.environ.get('TASK_TOKEN')\n        event_data = os.environ.get('INPUT_DATA', '{}')\n        if isinstance(event_data, str):\n            self.input_data = json.loads(event_data)\n        else:\n            self.input_data = event_data\n        logger.info(f\"Input data: {self.input_data}\")",
        "detail": "handlers.task_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "handlers.task_processor",
        "description": "handlers.task_processor",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nclass FargateTaskProcessor():\n    def __init__(self):\n        self.sfn_client = boto3.client('stepfunctions')\n        self.task_token = os.environ.get('TASK_TOKEN')\n        event_data = os.environ.get('INPUT_DATA', '{}')\n        if isinstance(event_data, str):\n            self.input_data = json.loads(event_data)\n        else:",
        "detail": "handlers.task_processor",
        "documentation": {}
    },
    {
        "label": "clean_text_for_vector_db",
        "kind": 2,
        "importPath": "indexing.indexing",
        "description": "indexing.indexing",
        "peekOfCode": "def clean_text_for_vector_db(text):\n    \"\"\"\n    Cleans the input text by removing quotes, special symbols, extra whitespaces,\n    newline (\\n), and tab (\\t) characters.\n    Args:\n        text (str): The input text to clean.\n    Returns:\n        str: The cleaned text.\n    \"\"\"\n    # Remove single and double quotes",
        "detail": "indexing.indexing",
        "documentation": {}
    },
    {
        "label": "chunk_embed_store",
        "kind": 2,
        "importPath": "indexing.indexing",
        "description": "indexing.indexing",
        "peekOfCode": "def chunk_embed_store(config : Config, experimentalConfig : ExperimentalConfig)-> None:\n    \"\"\"Main function to run the chunking and embedding pipeline.\"\"\"\n    experiment_dynamodb = DynamoDBOperations(region=config.aws_region, table_name=config.experiment_table)\n    logger.info(experiment_dynamodb.table)\n    try:\n        \"\"\"Main function to run the pipeline.\"\"\"\n        if not experimentalConfig.kb_data:\n            raise ValueError(\"S3 path is missing in the kb_data field.\")\n        pdf_folder_path = S3Util().download_directory_from_s3(experimentalConfig.kb_data)\n        # Step 1: Chunking",
        "detail": "indexing.indexing",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "indexing.indexing",
        "description": "indexing.indexing",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\ndef clean_text_for_vector_db(text):\n    \"\"\"\n    Cleans the input text by removing quotes, special symbols, extra whitespaces,\n    newline (\\n), and tab (\\t) characters.\n    Args:\n        text (str): The input text to clean.\n    Returns:\n        str: The cleaned text.",
        "detail": "indexing.indexing",
        "documentation": {}
    },
    {
        "label": "fetch_data_from_dynamodb",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "def fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"\n    try:\n        table = dynamodb.Table(table_name)\n        query_params = {\n            \"KeyConditionExpression\": boto3.dynamodb.conditions.Key(key).eq(value)\n        }\n        if index_name:",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "validate_event",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "def validate_event(event):\n    \"\"\"\n    Validate the input event to ensure required fields are present.\n    \"\"\"\n    required_fields = [\"experiment_id\"]\n    for field in required_fields:\n        if field not in event:\n            raise ValueError(f\"Missing required field: {field}\")\n    if not isinstance(event[\"experiment_id\"], str):\n        raise ValueError(\"'experiment_id' must be a string\")",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "lambda_handler",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "def lambda_handler(event, context):\n    \"\"\"\n    Lambda handler function.\n    \"\"\"\n    try:\n        logger.info(f\"Experiment Configuration received: {event}\")\n        # Validate input event\n        validate_event(event)\n        experiment_id = event[\"experiment_id\"]\n        experiment_table = os.getenv(\"experiment_table\")",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nMILLION = 1_000_000\nTHOUSAND = 1_000\nSECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "MILLION",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "MILLION = 1_000_000\nTHOUSAND = 1_000\nSECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "THOUSAND",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "THOUSAND = 1_000\nSECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "SECONDS_IN_MINUTE",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "SECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "MINUTES_IN_HOUR",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "MINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"\n    try:",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "HOURS_IN_DAY",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "HOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"\n    try:\n        table = dynamodb.Table(table_name)",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "DAYS_IN_MONTH",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "DAYS_IN_MONTH = 30\n# Initialize AWS services clients\ndynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"\n    try:\n        table = dynamodb.Table(table_name)\n        query_params = {",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "dynamodb",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.cost_compute_handler",
        "description": "lambda_handlers.cost_handler.cost_compute_handler",
        "peekOfCode": "dynamodb = boto3.resource(\"dynamodb\")\ndef fetch_data_from_dynamodb(table_name, key, value, index_name=None):\n    \"\"\"\n    Fetch items with the specified key and value from DynamoDB.\n    \"\"\"\n    try:\n        table = dynamodb.Table(table_name)\n        query_params = {\n            \"KeyConditionExpression\": boto3.dynamodb.conditions.Key(key).eq(value)\n        }",
        "detail": "lambda_handlers.cost_handler.cost_compute_handler",
        "documentation": {}
    },
    {
        "label": "compute_actual_price_breakdown",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"\n    is_input_valid, input_missing = validate_params(\n        configuration=configuration\n    )\n    if not is_input_valid:\n        logger.error(f\"Missing required parameters: {', '.join(input_missing)}.\")\n        return None",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "sagemaker_cost",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def sagemaker_cost(time, number_of_instances = 1):\n    instance_cost_per_hour = 1.210 #per hour ml.g5.2xlarge per model\n    overall_cost = instance_cost_per_hour * number_of_instances * ((time / SECONDS_IN_MINUTE) / MINUTES_IN_HOUR)\n    return overall_cost\ndef opensearch_cost(time):\n    number_of_instances = 3\n    instance_cost_per_hour = 0.711 # r7g.2xlarge.search\n    instance_total_cost = (instance_cost_per_hour * number_of_instances * (time / SECONDS_IN_MINUTE) / MINUTES_IN_HOUR)\n    ebs_volume_size = 10  # 2 GB\n    ebs_volume_price_per_month = .122 ",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "opensearch_cost",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def opensearch_cost(time):\n    number_of_instances = 3\n    instance_cost_per_hour = 0.711 # r7g.2xlarge.search\n    instance_total_cost = (instance_cost_per_hour * number_of_instances * (time / SECONDS_IN_MINUTE) / MINUTES_IN_HOUR)\n    ebs_volume_size = 10  # 2 GB\n    ebs_volume_price_per_month = .122 \n    ebs_total_cost = ebs_volume_price_per_month * ebs_volume_size * number_of_instances * ((time / SECONDS_IN_MINUTE) / MINUTES_IN_HOUR) / (HOURS_IN_DAY * DAYS_IN_MONTH) # 3 instances for 10GB each\n    iops_cost_per_month = .008\n    iops_per_instance = 16000  # instances per hour for 16000 IOPS (3000 free)\n    free_iops = 3000",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "ecs_cost",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def ecs_cost(time):\n    # 8 vCPU, 16 GB Memory\n    vCPU = 8\n    memory = 16\n    fargate_cpu_cost_per_vcpu = 0.04048 \n    fargate_memory_cost_per_gb = 0.004445\n    fargate_cpu_total_cost = fargate_cpu_cost_per_vcpu * vCPU\n    fargate_memory_total_cost = fargate_memory_cost_per_gb * memory\n    overall_cost = (fargate_cpu_total_cost + fargate_memory_total_cost) * ((time / SECONDS_IN_MINUTE) / MINUTES_IN_HOUR)\n    return overall_cost",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "calculate_experiment_duration",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def calculate_experiment_duration(experiment):\n    \"\"\"Calculate various durations (total, indexing, retrieval, evaluation) from the experiment dictionary.\"\"\"\n    try:\n        def calculate_difference(start_key, end_key):\n            if experiment.get(start_key) and experiment.get(end_key):\n                start = parse_datetime(experiment[start_key])\n                end = parse_datetime(experiment[end_key])\n                return (end - start).total_seconds()\n            return 0\n        # total_duration = calculate_difference(\"start_datetime\", \"end_datetime\")",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "calculate_experiment_question_details",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def calculate_experiment_question_details(experiment_question_metrics_items):\n    total_questions = len(experiment_question_metrics_items)\n    overall_inferencer_time = 0\n    average_inferencer_time = 0\n    reranker_queries = 0\n    for question in experiment_question_metrics_items:\n        answer_metadata = question.get(\"answer_metadata\", None)\n        if answer_metadata:\n            latency = answer_metadata.get(\"latencyMs\", 0)\n            inputTokens = answer_metadata.get('inputTokens', 0)",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "validate_params",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "def validate_params(**kwargs):\n    \"\"\"\n    Validates the given parameters and identifies missing ones.\n    Args:\n        **kwargs: Key-value pairs of parameter names and their values.\n    Returns:\n        tuple: A boolean indicating if there are missing parameters and a list of missing parameter names.\n    \"\"\"\n    missing_params = [param for param, value in kwargs.items() if not value]\n    return not missing_params, missing_params",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "MILLION",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "MILLION = 1_000_000\nTHOUSAND = 1_000\nSECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "THOUSAND",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "THOUSAND = 1_000\nSECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "SECONDS_IN_MINUTE",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "SECONDS_IN_MINUTE = 60\nMINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "MINUTES_IN_HOUR",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "MINUTES_IN_HOUR = 60\nHOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "HOURS_IN_DAY",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "HOURS_IN_DAY = 24\nDAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "DAYS_IN_MONTH",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "DAYS_IN_MONTH = 30\nlogger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ns3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"\n    is_input_valid, input_missing = validate_params(",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "s3",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "s3 = boto3.client(\"s3\")\nS3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"\n    is_input_valid, input_missing = validate_params(\n        configuration=configuration\n    )",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "S3_BUCKET",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "S3_BUCKET = os.getenv(\"s3_bucket\")\nBEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"\n    is_input_valid, input_missing = validate_params(\n        configuration=configuration\n    )\n    if not is_input_valid:",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "BEDROCK_CSV_PATH",
        "kind": 5,
        "importPath": "lambda_handlers.cost_handler.pricing",
        "description": "lambda_handlers.cost_handler.pricing",
        "peekOfCode": "BEDROCK_CSV_PATH = os.getenv(\"bedrock_limit_csv\")\ndef compute_actual_price_breakdown(\n    configuration, input_tokens, output_tokens, index_embed_tokens, query_embed_tokens, total_time, indexing_time, retrieval_time, eval_time, experiment_question_metrics_items\n):\n    \"\"\"Compute the actual price based on the given configuration and token/time inputs.\"\"\"\n    is_input_valid, input_missing = validate_params(\n        configuration=configuration\n    )\n    if not is_input_valid:\n        logger.error(f\"Missing required parameters: {', '.join(input_missing)}.\")",
        "detail": "lambda_handlers.cost_handler.pricing",
        "documentation": {}
    },
    {
        "label": "read_csv_from_s3",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.utils",
        "description": "lambda_handlers.cost_handler.utils",
        "peekOfCode": "def read_csv_from_s3(object_key: str, bucket_name: str, as_dataframe: bool = True) -> Optional[object]:\n    \"\"\"\n    Read CSV data from S3 and convert it to a list of dictionaries or a pandas DataFrame.\n    Args:\n        object_key (str): The key (path) of the S3 object.\n        bucket_name (str): The name of the S3 bucket.\n        as_dataframe (bool): If True, return a pandas DataFrame, otherwise return a list of dictionaries.\n    Returns:\n        Optional[object]: List of dictionaries or pandas DataFrame containing the CSV data if successful, None otherwise.\n    Raises:",
        "detail": "lambda_handlers.cost_handler.utils",
        "documentation": {}
    },
    {
        "label": "parse_datetime",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.utils",
        "description": "lambda_handlers.cost_handler.utils",
        "peekOfCode": "def parse_datetime(datetime_str):\n    if not datetime_str:\n        return None\n    try:\n        dt = datetime.strptime(datetime_str, '%Y-%m-%dT%H:%M:%S.%fZ')\n    except ValueError:\n        dt = datetime.strptime(datetime_str, '%Y-%m-%dT%H:%M:%S%z')\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=timezone.utc)\n    return dt",
        "detail": "lambda_handlers.cost_handler.utils",
        "documentation": {}
    },
    {
        "label": "convert_floats_to_decimal",
        "kind": 2,
        "importPath": "lambda_handlers.cost_handler.utils",
        "description": "lambda_handlers.cost_handler.utils",
        "peekOfCode": "def convert_floats_to_decimal(obj):\n    if isinstance(obj, float):\n        return Decimal(str(obj))  # Convert float to string first to prevent precision loss\n    elif isinstance(obj, dict):\n        return {k: convert_floats_to_decimal(v) for k, v in obj.items()}\n    elif isinstance(obj, list):\n        return [convert_floats_to_decimal(i) for i in obj]\n    else:\n        return obj",
        "detail": "lambda_handlers.cost_handler.utils",
        "documentation": {}
    },
    {
        "label": "lambda_handler",
        "kind": 2,
        "importPath": "lambda_handlers.evaluation_handler",
        "description": "lambda_handlers.evaluation_handler",
        "peekOfCode": "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the eval method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing status and message\n    \"\"\"\n    try:",
        "detail": "lambda_handlers.evaluation_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.evaluation_handler",
        "description": "lambda_handlers.evaluation_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ndef lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the eval method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing status and message",
        "detail": "lambda_handlers.evaluation_handler",
        "documentation": {}
    },
    {
        "label": "lambda_handler",
        "kind": 2,
        "importPath": "lambda_handlers.indexing_handler",
        "description": "lambda_handlers.indexing_handler",
        "peekOfCode": "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the retrieve method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details\n    \"\"\"\n    try:",
        "detail": "lambda_handlers.indexing_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.indexing_handler",
        "description": "lambda_handlers.indexing_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ndef lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the retrieve method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details",
        "detail": "lambda_handlers.indexing_handler",
        "documentation": {}
    },
    {
        "label": "lambda_handler",
        "kind": 2,
        "importPath": "lambda_handlers.opensearch_handler",
        "description": "lambda_handlers.opensearch_handler",
        "peekOfCode": "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to create OpenSearch indices based on experiment configurations.\n    Args:\n        event (Dict[str, Any]): Lambda event containing experiment configurations\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details\n    \"\"\"\n    try:",
        "detail": "lambda_handlers.opensearch_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.opensearch_handler",
        "description": "lambda_handlers.opensearch_handler",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogging.basicConfig(level=logging.INFO)\ndef lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to create OpenSearch indices based on experiment configurations.\n    Args:\n        event (Dict[str, Any]): Lambda event containing experiment configurations\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details",
        "detail": "lambda_handlers.opensearch_handler",
        "documentation": {}
    },
    {
        "label": "lambda_handler",
        "kind": 2,
        "importPath": "lambda_handlers.retriever_handler",
        "description": "lambda_handlers.retriever_handler",
        "peekOfCode": "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the retrieve method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details\n    \"\"\"\n    try:",
        "detail": "lambda_handlers.retriever_handler",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "lambda_handlers.retriever_handler",
        "description": "lambda_handlers.retriever_handler",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\ndef lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:\n    \"\"\"\n    Lambda handler to invoke the retrieve method.\n    Args:\n        event (Dict[str, Any]): Lambda event containing configuration parameters\n        context (Any): Lambda context object\n    Returns:\n        Dict[str, Any]: Response containing execution status and details",
        "detail": "lambda_handlers.retriever_handler",
        "documentation": {}
    },
    {
        "label": "OpenSearchIndex",
        "kind": 6,
        "importPath": "opensearch.opensearch_index_manager",
        "description": "opensearch.opensearch_index_manager",
        "peekOfCode": "class OpenSearchIndex:\n    \"\"\"\n    Data class representing the configuration for an OpenSearch index.\n    Attributes:\n        name (str): Unique identifier for the index\n        algorithm (str): Indexing algorithm to be used\n        vector_field (str): Name of the vector field\n        dimension (int): Dimensionality of the vector\n    \"\"\"\n    name: str",
        "detail": "opensearch.opensearch_index_manager",
        "documentation": {}
    },
    {
        "label": "OpenSearchIndexManager",
        "kind": 6,
        "importPath": "opensearch.opensearch_index_manager",
        "description": "opensearch.opensearch_index_manager",
        "peekOfCode": "class OpenSearchIndexManager:\n    \"\"\"\n    Manager class for handling OpenSearch index operations.\n    Responsible for initializing OpenSearch connections and creating indices.\n    \"\"\"\n    def __init__(self, config: Config):\n        \"\"\"\n        Initialize the OpenSearch index manager.\n        Args:\n            config (Config): Configuration object with OpenSearch connection details",
        "detail": "opensearch.opensearch_index_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "opensearch.opensearch_index_manager",
        "description": "opensearch.opensearch_index_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass OpenSearchIndex:\n    \"\"\"\n    Data class representing the configuration for an OpenSearch index.\n    Attributes:\n        name (str): Unique identifier for the index\n        algorithm (str): Indexing algorithm to be used\n        vector_field (str): Name of the vector field\n        dimension (int): Dimensionality of the vector",
        "detail": "opensearch.opensearch_index_manager",
        "documentation": {}
    },
    {
        "label": "RetrievalError",
        "kind": 6,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "class RetrievalError(Exception):\n    \"\"\"Custom exception for retrieval process errors.\"\"\"\n    pass",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "retrieve",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def retrieve(config: Config, experimentalConfig: ExperimentalConfig) -> None:\n    \"\"\"\n    Execute the retrieval process for question answering experiments.\n    Args:\n        config (Config): Global configuration object\n        experimentalConfig (ExperimentalConfig): Experiment-specific configuration\n    Raises:\n        RetrievalError: If the retrieval process fails\n    \"\"\"\n    try:",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "initialize_components",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def initialize_components(config: Config, experimentalConfig: ExperimentalConfig) -> Dict[str, Any]:\n    \"\"\"Initialize all required components for the retrieval process.\"\"\"\n    try:\n        # Initialize embedding processor if required\n        if experimentalConfig.bedrock_knowledge_base or not experimentalConfig.knowledge_base:\n            logger.info(\"Skipping embed processor initialization\")\n            embed_processor = None\n        else:\n            logger.info(\"Initializing embedding processor\")\n            embed_processor = EmbedProcessor(experimentalConfig)",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "apply_guardrail_check",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def apply_guardrail_check(components, guardrail_id, content, source, log_prefix):\n    \"\"\"Helper function to apply guardrails and process response\n    Args:\n        components: Dictionary containing guardrail components\n        guardrail_id: ID of the guardrail to apply\n        content: Content to check against guardrails\n        source: Source type ('INPUT', 'OUTPUT', etc.)\n        log_prefix: Prefix for logging messages\n    Returns:\n        Tuple of (blocked, modified_text, assessment)",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "load_ground_truth_data",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def load_ground_truth_data(experimentalConfig: ExperimentalConfig) -> List[Dict]:\n    \"\"\"Load ground truth data from S3.\"\"\"\n    logger.info(f\"Reading ground truth data from S3: {experimentalConfig.gt_data}\")\n    return S3Util().read_json_from_s3(experimentalConfig.gt_data)\ndef process_questions(\n    gt_data: List[Dict],\n    components: Dict[str, Any],\n    config: Config,\n    experimentalConfig: ExperimentalConfig,\n) -> Tuple[int, int, int]:",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "process_questions",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def process_questions(\n    gt_data: List[Dict],\n    components: Dict[str, Any],\n    config: Config,\n    experimentalConfig: ExperimentalConfig,\n) -> Tuple[int, int, int]:\n    \"\"\"Process questions and store results in DynamoDB.\"\"\"\n    batch_items = []\n    logger.info(f\"Processing {len(gt_data)} questions from ground truth data\")\n    retrieval_query_embed_tokens = 0",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "write_batch_to_dynamodb",
        "kind": 2,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "def write_batch_to_dynamodb(batch_items: List[Dict], dynamodb: DynamoDBOperations) -> None:\n    \"\"\"Write a batch of items to DynamoDB.\"\"\"\n    logger.info(f\"Writing batch of {len(batch_items)} items to DynamoDB\")\n    dynamodb.batch_write(batch_items)\nclass RetrievalError(Exception):\n    \"\"\"Custom exception for retrieval process errors.\"\"\"\n    pass",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "retriever.retriever",
        "description": "retriever.retriever",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n# Function to retrieve and process data using Vectorstore and inference models\nfrom typing import List, Dict, Any, Optional, Tuple, Union\nfrom dataclasses import asdict\ndef retrieve(config: Config, experimentalConfig: ExperimentalConfig) -> None:\n    \"\"\"\n    Execute the retrieval process for question answering experiments.\n    Args:\n        config (Config): Global configuration object",
        "detail": "retriever.retriever",
        "documentation": {}
    },
    {
        "label": "KnowledgeBaseUtils",
        "kind": 6,
        "importPath": "util.bedrock_utils",
        "description": "util.bedrock_utils",
        "peekOfCode": "class KnowledgeBaseUtils():\n    def __init__(self, region):\n        \"\"\"Initialize KnowledgeBaseUtils with config and bedrock-agent client\"\"\"\n        self.config = Config.load_config()\n        self.client = boto3.client(\"bedrock-agent\", region_name=region)\n    def list_knowledge_bases(self):\n        \"\"\"\n        List and filter vector knowledge bases that contain documents.\n        Returns:\n            list: List of dictionaries containing knowledge base IDs and names that:",
        "detail": "util.bedrock_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "util.bedrock_utils",
        "description": "util.bedrock_utils",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass KnowledgeBaseUtils():\n    def __init__(self, region):\n        \"\"\"Initialize KnowledgeBaseUtils with config and bedrock-agent client\"\"\"\n        self.config = Config.load_config()\n        self.client = boto3.client(\"bedrock-agent\", region_name=region)\n    def list_knowledge_bases(self):\n        \"\"\"\n        List and filter vector knowledge bases that contain documents.",
        "detail": "util.bedrock_utils",
        "documentation": {}
    },
    {
        "label": "BedRockRetryHander",
        "kind": 6,
        "importPath": "util.boto3_utils",
        "description": "util.boto3_utils",
        "peekOfCode": "class BedRockRetryHander(BotoRetryHandler):\n    \"\"\"Retry handler for Bedrock service.\"\"\"\n    @property\n    def retry_params(self) -> RetryParams:\n        return RetryParams(\n            max_retries=5,\n            retry_delay=2,\n            backoff_factor=2\n        )\n    @property",
        "detail": "util.boto3_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "util.boto3_utils",
        "description": "util.boto3_utils",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\nclass BedRockRetryHander(BotoRetryHandler):\n    \"\"\"Retry handler for Bedrock service.\"\"\"\n    @property\n    def retry_params(self) -> RetryParams:\n        return RetryParams(\n            max_retries=5,\n            retry_delay=2,\n            backoff_factor=2",
        "detail": "util.boto3_utils",
        "documentation": {}
    },
    {
        "label": "DateTimeUtils",
        "kind": 6,
        "importPath": "util.date_time_utils",
        "description": "util.date_time_utils",
        "peekOfCode": "class DateTimeUtils:\n    @staticmethod\n    def parse_datetime(datetime_str):\n        if not datetime_str:\n            return None\n        try:\n            dt = datetime.strptime(datetime_str, '%Y-%m-%dT%H:%M:%S.%fZ')\n        except ValueError:\n            dt = datetime.strptime(datetime_str, '%Y-%m-%dT%H:%M:%S%z')\n        if dt.tzinfo is None:",
        "detail": "util.date_time_utils",
        "documentation": {}
    },
    {
        "label": "deserialize_dynamodb_json",
        "kind": 2,
        "importPath": "util.dynamo_utils",
        "description": "util.dynamo_utils",
        "peekOfCode": "def deserialize_dynamodb_json(dynamodb_json: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Deserialize DynamoDB JSON to regular Python dictionary.\n    Args:\n        dynamodb_json (Dict[str, Any]): DynamoDB JSON formatted dictionary\n    Returns:\n        Dict[str, Any]: Regular Python dictionary\n    \"\"\"\n    # Handle None/Null response from DynamoDB\n    if dynamodb_json is None:",
        "detail": "util.dynamo_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "util.dynamo_utils",
        "description": "util.dynamo_utils",
        "peekOfCode": "logger = logging.getLogger()\nlogging.basicConfig(level=logging.INFO)\ndef deserialize_dynamodb_json(dynamodb_json: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Deserialize DynamoDB JSON to regular Python dictionary.\n    Args:\n        dynamodb_json (Dict[str, Any]): DynamoDB JSON formatted dictionary\n    Returns:\n        Dict[str, Any]: Regular Python dictionary\n    \"\"\"",
        "detail": "util.dynamo_utils",
        "documentation": {}
    },
    {
        "label": "create_error_response",
        "kind": 2,
        "importPath": "util.error_handling",
        "description": "util.error_handling",
        "peekOfCode": "def create_error_response(error_type: str, description: str):\n    \"\"\"\n    Constructs a consistent error response.\n    Args:\n        error_type (str): The type of the error (e.g., VALIDATION_ERROR).\n        description (str): A human-readable description of the error.\n        field (str, optional): The field causing the error.\n        location (str, optional): The location of the field (e.g., body, prestep).\n    Returns:\n        dict: A structured error response.",
        "detail": "util.error_handling",
        "documentation": {}
    },
    {
        "label": "GuardRailsUtils",
        "kind": 6,
        "importPath": "util.guard_rails_utils",
        "description": "util.guard_rails_utils",
        "peekOfCode": "class GuardRailsUtils:\n    @staticmethod\n    def get_bedrock_guardrails(region) -> List[Dict]:\n        \"Static method to fetch AWS Bedrock guardrails.\"\n        try:\n            client = boto3.client('bedrock', region_name=region)\n            logger.info(\"Fetching guardrails.\")            \n            response = client.list_guardrails()\n            guardrails = response.get(\"guardrails\", [])\n            logger.info(\"Guardrails fetched.\")",
        "detail": "util.guard_rails_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "util.guard_rails_utils",
        "description": "util.guard_rails_utils",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\nclass GuardRailsUtils:\n    @staticmethod\n    def get_bedrock_guardrails(region) -> List[Dict]:\n        \"Static method to fetch AWS Bedrock guardrails.\"\n        try:\n            client = boto3.client('bedrock', region_name=region)\n            logger.info(\"Fetching guardrails.\")            \n            response = client.list_guardrails()",
        "detail": "util.guard_rails_utils",
        "documentation": {}
    },
    {
        "label": "OpenSearchUtils",
        "kind": 6,
        "importPath": "util.open_search_config_utils",
        "description": "util.open_search_config_utils",
        "peekOfCode": "class OpenSearchUtils:\n    @staticmethod\n    def opensearch_config():\n        opensearch_endpoint = os.getenv(\"OPENSEARCH_ENDPOINT\")\n        configured = bool(opensearch_endpoint)  # True if string is not empty/None, otherwise False.\n        return {\"configured\": configured}",
        "detail": "util.open_search_config_utils",
        "documentation": {}
    },
    {
        "label": "extract_text_from_pdf",
        "kind": 2,
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "peekOfCode": "def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"Extract text from a PDF file.\"\"\"\n    try:\n        logger.info(f\"Extracting text from PDF: {file_path}\")\n        reader = PdfReader(file_path)\n        text = \"\"\n        for page in reader.pages:\n            text += page.extract_text() or \"\"\n        logger.info(\"Text extraction from PDF successful.\")\n        return text",
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "extract_text_from_pdf_pymudf",
        "kind": 2,
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "peekOfCode": "def extract_text_from_pdf_pymudf(file_path: str) -> str:\n    \"\"\"Extract text from a PDF file.\"\"\"\n    try:\n        logger.info(f\"Extracting text from PDF: {file_path}\")\n        doc = fitz.open(file_path)\n        text_buffer = StringIO()\n        for page in doc:\n            page_text = page.get_text() or \"\"\n            text_buffer.write(page_text)\n        logger.info(\"Text extraction from PDF successful.\")",
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "process_pdf_from_folder",
        "kind": 2,
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "peekOfCode": "def process_pdf_from_folder(file_path: str) -> str:\n    \"Extract text from all files in a folder\"\n    try:\n        text_data = []\n        for file in os.listdir(file_path):\n            file_text = extract_text_from_pdf(os.path.join(file_path, file))\n            text_data.append(file_text)\n        logger.info(f\"Extracted text from all files. Number of files: {len(text_data)}\")\n        return text_data\n    except Exception as e:",
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "util.pdf_utils",
        "description": "util.pdf_utils",
        "peekOfCode": "logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\ndef extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"Extract text from a PDF file.\"\"\"\n    try:\n        logger.info(f\"Extracting text from PDF: {file_path}\")\n        reader = PdfReader(file_path)\n        text = \"\"\n        for page in reader.pages:\n            text += page.extract_text() or \"\"",
        "detail": "util.pdf_utils",
        "documentation": {}
    },
    {
        "label": "S3Util",
        "kind": 6,
        "importPath": "util.s3util",
        "description": "util.s3util",
        "peekOfCode": "class S3Util:\n    \"\"\"Utility class for reading JSON data from AWS S3 and converting it to dictionary.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize S3 client.\"\"\"\n        self.s3_client = boto3.client('s3')\n        self.logger = logging.getLogger(__name__)\n    def read_json_from_s3(self, s3_path: str) -> Optional[Dict]:\n        \"\"\"\n        Read JSON data from S3 and convert it to a dictionary.\n        Args:",
        "detail": "util.s3util",
        "documentation": {}
    }
]